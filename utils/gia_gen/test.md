似乎已经有了一个清晰的框架, 但还有一些小问题:
在子系统B中, Kernel_2000(或Type5) 的次序为0的引脚有一个额外字段对应外壳id, SendSignal的次序为1的引脚是名称.
在子系统A中, 除了 SendSignal 和 ListenSignal 其余节点均不包含 Type5 的引脚. 但是子系统A的这两个节点的只有一个Type5是次序为0的引脚为名称. 它们使用的Kernel的id与外壳id相同(动态id). 能否分析出更多的机制?

此外, 一些隐藏引脚具有固定值, 可变类型节点也有一些引脚具有可变的固定值(随类型变化), 这如何处理?


composite 定义分为两个部分: 外壳定义与内部结构定义.
外壳定义非常简单: 有哪些引脚, 是什么类型, 有什么名字, 并分配一个全局的 composite pin id (从1开始)
内部结构定义包含基本的图结构, 并单独保存了对外的引脚列表(compositePins), 每一项均包含这些信息: 连接到了哪一个外壳引脚(组别和index), 内部连接的是哪个节点的哪个引脚(nodeIndex + pinType/Index of Shell and Kernel)


外壳定义非常简单: 有哪些引脚, 是什么类型, 有什么名字, 并分配一个全局的 composite pin id (从1开始) **可以用来导出枚举的id和类型扩展**
结构不能说很差吧, 反正不好.