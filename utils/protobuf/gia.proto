syntax = "proto3";
// @version: 2.0.0
// package gia;

// .gia file (Genshin Impact Assets)
message AssetBundle {
  // 主要
  ResourceEntry          primary_resource = 1; // 主要导出对象
  repeated ResourceEntry dependencies     = 2; // 包含所有生成的存根、结构体、信号等
  string                 export_tag       = 3; // {UID}-{TIME}-{LEVEL_ID}-\{EXPORT_FILE_NAME}.gia // 或者叫导出信息
  string                 engine_version   = 5; // 6.2.0 by now
}

// 通用资源标识符 (原 ResourceLocator, NodeProperty 等)
// 这是整个系统中"资源的身份证"
message ResourceLocator {

  // Origin (来源域)：
  //   - 含义：定义了资源的“所有权”和“存储位置”。
  //   - USER_DEFINED: 存在于玩家/开发者动态生成的数据库中。
  //   - SYSTEM_DEFINED: 存在于游戏安装包的静态只读数据中。
  enum Origin {
    UNKNOWN_CLASS  = 0;
    USER_DEFINED   = 10000; // 用户资产
    SYSTEM_DEFINED = 10001; // 系统内置
  }

  // Category (服务域/子系统)：
  //   - 含义：定义了哪个“引擎模块”负责处理此资源。
  //   - 例如：SERVER_BASIC 归后端逻辑引擎管，CLIENT_FILTER 归前端表现引擎管。它决定了数据加载后的分发路径。
  enum Category {
    UNKNOWN_TYPE = 0;

    // 资产类型
    FILTER_NODE_GRAPH     = 1; // Such as boolean filter
    BASIC_NODE_GRAPH      = 5; // Such as graph node
    AFFILIATED_NODE_GRAPH = 23; // Assembly/Split for Structure

    // Server Side Node Types
    SERVER_BASIC  = 20000;
    SERVER_STATUS = 20003;
    SERVER_CLASS  = 20004;
    SERVER_ITEM   = 20005;

    // Client Side Node Types
    CLIENT_FILTER     = 20001; // 筛选器类型(默认 Bool)
    CLIENT_SKILL      = 20002; // 技能节点图流程(客户端)
    CLIENT_INT_FILTER = 20006; // 整数筛选器类型
  }

  // AssetKind/Kind (原型域/数据结构)：
  //   - 含义：定义了数据的物理结构。
  //   - 它告诉解析器：这个资源是一个 COMPOSITE_GRAPH 结构，还是一个 STRUCTURE 结构。
  enum AssetKind {
    // 资产类型
    BASIC                   = 0; // 服务器节点图, 等一些列未定义的(默认值)
    PREFAB                  = 1; // 预制体（元件）、玩家模板或角色模板
    ENTITY                  = 2; // 实体或造物
    CLIENT_NODE_GRAPH       = 3; // 客户端节点图
    CONFIGURATION           = 4; // 配置信息 (可能有误)
    TERRAIN                 = 5; // 地形
    UI                      = 8; // 界面布局或交互控件
    PRESET_POINT            = 9; // 预设点
    DECORATION              = 14; // 装饰物
    STRUCTURE               = 15; // 结构体
    ENTITY_DEPLOYMENT_GROUP = 18; // 实体布设组
    PATH                    = 19; // 路径
    UNIT_TAG                = 23; // 单位标签

    // 节点图子类型
    CUSTOM_GRAPH    = 21001; // NodeGraph
    COMPOSITE_GRAPH = 21002; // CompositeGraph

    // 节点子类型
    SYS_CALL_STUB  = 22000; // SysCall (Kernel 2000/2001 等)
    GENERATED_STUB = 22001; // SysGraph (Struct/Signal 定义生成的节点)
  }

  Origin    source_domain  = 1; // 开发者 vs 系统
  Category  service_domain = 2; // 后端逻辑 vs 前端表现
  AssetKind kind           = 3; // 物理数据结构分类

  // ====== Optional ======

  // world_entity_guid: EntityUid, 全局/世界空间, 有实体的对象。
  //   - 如 Prefab、Character、Item。
  //   - 它们在游戏的世界数据库（World DB）中有唯一的全球唯一标识符，可以通过 API 直接查询其实体属性。
  int64 world_entity_guid = 4;

  // internal_logic_id: LogicId, 逻辑/局部空间, 纯数据对象。
  //   - 如 NodeGraph、NodeInterface、Signal。
  //   - 它们不是世界中的“东西”，而是代码或配置。它们通过 ID 在逻辑引擎内部索引。
  int64 internal_logic_id = 5;

  // 简单判定法：如果这个东西在游戏场景里能被“生出来”（Spawn），它用 guid；如果这个东西只是一段逻辑或一个定义，它用 id。
}

message ResourceEntry  {
  enum AssetType {
    UNKNOWN_TYPE            = 0; // 未知类型
    PREFAB                  = 1; // 预制体（元件）
    CREATION                = 2; // 造物
    ENTITY                  = 3; // 实体
    TERRAIN                 = 5; // 地形
    PRESET_POINT            = 6; // 预设点
    UNIT_STATUS             = 7; // 单位状态
    SKILL                   = 8; // 技能
    ENTITY_NODE_GRAPH       = 9; // 实体节点图
    BOOLEAN_FILTER_GRAPH    = 10; // 布尔过滤器 (节点图)
    SKILL_NODE_GRAPH        = 11; // 技能节点图
    COMPOSITE_NODE_DECL     = 12; // 复合节点声明 (含监听信号、修改/拆分/拼装结构体)
    CAMERA                  = 13; // 镜头
    SIGNAL_NODE_DECL        = 14; // 信号节点声明 (发送信号、向服务器节点图发送信号)
    UI_CONTROL              = 15; // 交互控件
    SKILL_RESOURCE          = 16; // 技能资源
    PLAYER                  = 18; // 玩家模板
    CHARACTER               = 19; // 角色模板
    INTERFACE_LAYOUT        = 20; // 界面布局
    UI_CONTROL_GROUP        = 21; // 界面控件组
    STATUS_NODE_GRAPH       = 22; // 状态节点图
    CLASS_NODE_GRAPH        = 23; // 职业节点图
    GLOBAL_TIMER            = 24; // 全局计时器
    ITEM                    = 26; // 道具
    DECORATION              = 28; // 装饰物
    STRUCTURE               = 29; // 结构体定义
    SHOP                    = 30; // 商店
    LEVEL_STRUCTURE         = 37; // 关卡结构体定义
    PATH                    = 38; // 路径
    SHIELD                  = 39; // 护盾
    ENTITY_DEPLOYMENT_GROUP = 43; // 实体布设组
    UNIT_TAG                = 44; // 单位标签
    SCAN_TAG                = 45; // 扫描标签
    ITEM_NODE_GRAPH         = 46; // 道具节点图
    INTEGER_FILTER_GRAPH    = 47; // 整数过滤器 (节点图)
    LIGHT_SOURCE            = 48; // 光源
    ENVIRONMENT             = 49; // 环境配置
    // reserved 4, 17, 25, 27, 31 to 36, 40 to 42;
  };

  ResourceLocator          identity       = 1; // 自身 ID
  repeated ResourceLocator reference_list = 2; // 显式依赖表
  string                   internal_name  = 3; // 如节点图名称
  AssetType                resource_class = 5; // 对节点图说, 明确限定了它的类型

  oneof payload {
    NodeGraphContainer           graph_data     = 13; // Which is Node Graph
    NodeInterfaceContainer       interface_data = 14; // Which is Interface Definition
    StructureDefinitionContainer struct_data    = 22; // Which is Structure Definition

    // EntityDefinition      entity       = 11;
    // Configuration         config       = 15;
    // Terrain               terrain      = 16;
    // Camera                camera       = 17;
    // PresetPoint           point        = 18;
    // UiControlGroup        ui           = 19;
    // GlobalTimer           timer        = 20;
    // UnitTag               unit_tag     = 26;
    // EntityDeploymentGroup deployment   = 27;
  }
}

// ### 包装结构分析：为何需要 Wrapper？
// 代码中出现了 NodeGraphWrapper 和 CompositeDefWrapper 且内部嵌套了 InnerWrapper。这种设计在大型引擎（如 Unity 或自定义引擎）中非常常见，原因有三：
//   - 类型擦除与异构容器：在 oneof 中，如果直接放入原始消息，未来如果想给所有类型的资源添加“通用元数据”（如加密标志、压缩算法、版本号），就必须修改每个具体消息。
//   - 版本平滑迁移 (Forward Compatibility)：InnerWrapper 提供了一个缓冲区。如果 NodeGraph 的结构发生断代式更新，引擎可以先解析 Wrapper 层的版本号，再决定调用哪个版本的解析器。
//   - 内存布局优化：在某些序列化框架中，这种嵌套允许引擎在不完全反序列化内部逻辑的情况下，先读取资源的“外壳”信息（如 ID 和名称）。

message NodeGraphContainer {
  message InnerWrapper { NodeGraph graph = 1; }
  InnerWrapper inner = 1;
}

message NodeInterfaceContainer {
  message InnerWrapper { NodeInterface interface = 1; }
  InnerWrapper inner = 1;
}

message StructureDefinitionContainer {
  message StructureDef {
    Field genericField  = 1;
    Field concreteField = 2; // same as 1
    int32 structVersion = 3; // Version Updated as structure is modified and as
                             // other structures modified
    int32 itemCount = 4; // item count
  }
  message Field {
    int64           id   = 1;
    int64           xxx  = 2; // 2 for level stru def
    repeated VarDef vars = 3;

    string structName = 501;
    int32  classBase  = 502; // always 1
    int32  index      = 503; // same as StructureDef
  }
  message VarDef {

    message TypeDef {
      message SubType {
        VarType type    = 1;
        int64   xxxx_id = 2; // What are they?
        VarType key     = 502;
        VarType value   = 503;
        int64   valueId = 504;
      }
      VarType type    = 1;
      SubType subType = 2;

      oneof val {
        IntBaseValue    intVal  = 13;
        EnumBaseValue   boolVal = 14;
        StringBaseValue strVal  = 16;
        // TODO: What A mess here! I can't bear anymore!!!!!
        // He who trust himself could take a try.
        // ESPECIALLY MAP/STRUCT BASE
      }
    }
    message TypeDef3 {
      message SubType {
        VarType type = 1;
        message Any {}
        Any     xxxx_id = 2; // Why diff from TypeDef3
        VarType key     = 502;
        VarType value   = 503;
        int64   valueId = 504;
      }
      VarType type    = 1;
      SubType subType = 2;

      oneof val {
        IntBaseValue    intVal  = 13;
        EnumBaseValue   boolVal = 14;
        StringBaseValue strVal  = 16;
        // TODO: What A mess here! I can't bear anymore!!!!!
        // He who trust himself could take a try.
        // ESPECIALLY MAP/STRUCT BASE
      }
    }
    TypeDef  typedef1 = 1;
    TypeDef3 typedef3 = 3;
    string   name     = 5;

    string  varName  = 501;
    VarType varType  = 502;
    int32   varIndex = 503; // variable index
  }
  StructureDef def = 1;
}

// ========== Begin of Variable Defs ========== //
enum VarType {
  UnknownVar       = 0;
  Entity           = 1;
  GUID             = 2;
  Integer          = 3;
  Boolean          = 4;
  Float            = 5;
  String           = 6;
  GUIDList         = 7;
  IntegerList      = 8;
  BooleanList      = 9;
  FloatList        = 10;
  StringList       = 11;
  Vector           = 12;
  EntityList       = 13;
  EnumItem         = 14;
  VectorList       = 15;
  LocalVariableRef = 16;
  Faction          = 17;
  EnumList         = 18;
  // reserved 19;
  Configuration       = 20;
  Prefab              = 21;
  ConfigurationList   = 22;
  PrefabList          = 23;
  FactionList         = 24;
  Struct              = 25;
  StructList          = 26;
  Dictionary          = 27;
  VariableSnapshotRef = 28;

  // EnumTypes 10001.....
  // reserved 10000 to 10099;   // server enum types
  // reserved 210000 to 210099; // client enum types
}

enum ClientVarType {
  UnknownVar_        = 0;
  Entity_            = 1; // type: Ety, typeid: 1
  EntityList_        = 2; // type: L<Ety>, typeid: 2
  Integer_           = 3; // type: Int, typeid: 3
  IntegerList_       = 4; // type: L<Int>, typeid: 4
  Boolean_           = 5; // type: Bol, typeid: 5
  BooleanList_       = 6; // type: L<Bol>, typeid: 6
  Float_             = 7; // type: Flt, typeid: 7
  FloatList_         = 8; // type: L<Flt>, typeid: 8
  String_            = 9; // type: Str, typeid: 9
  StringList_        = 10; // type: L<Str>, typeid: 10
  Vector_            = 11; // type: Vec, typeid: 11
  VectorList_        = 12; // type: L<Vec>, typeid: 12
  EnumItem_          = 13; // type: E<Unk>, typeid: 13
  GUID_              = 14; // type: Gid, typeid: 14
  GUIDList_          = 15; // type: L<Gid>, typeid: 15
  Faction_           = 16; // type: Fct, typeid: 16
  EnumList_          = 17; // type: L<E<Unk>>, typeid: 17
  Configuration_     = 18; // type: Cfg, typeid: 18
  Prefab_            = 19; // type: Pfb, typeid: 19
  ConfigurationList_ = 20; // type: L<Cfg>, typeid: 20
}

message VarBase {
  enum Class {
    Unknown      = 0;
    IdBase       = 1;
    IntBase      = 2;
    SelectorBase = 3; // (But how to set options?)
    FloatBase    = 4;
    StringBase   = 5;
    EnumBase     = 6;
    VectorBase   = 7;

    ConcreteBase = 10000; // reflective pins
    StructBase   = 10001;
    ArrayBase    = 10002;
    MapBase      = 10003;

    MapPair = 10007;
  }
  message ItemType {
    message StructItem { int64 structId = 1; }
    message PairItems {
      VarType        key      = 1;
      VarType        value    = 2;
      optional int64 structId = 3; // only when value is struct
    }
    message ClientType {
      ClientVarType type = 2; // 不是, 怎么类型枚举都不一样. 想死了
    }
    message ServerType {
      enum Kind {
        Normal = 0;
        Struct = 1;
        Pair   = 2;
      }
      VarType type = 1;
      Kind    kind = 2;
      oneof id {
        StructItem item  = 100;
        PairItems  items = 101;
      }
    }
    enum ClassBase {
      Unknown = 0;
      Server  = 1;
      Client  = 2;
    }
    ClassBase classBase = 1;
    oneof class {
      ServerType type_server = 100;
      ClientType type_client = 101;
    }
  }
  message StructInfo {
    // TODO: What is this
    message Inner { int32 xxx = 1; }
    int32 xxx   = 1;
    Inner inner = 100;
  }

  Class             class             = 1;
  int32             xxx_alreadySetVal = 2;
  optional ItemType itemType          = 4;
  // Only Struct contains this field
  optional StructInfo structInfo = 5;

  // decided by class, id = class + 100, except Struct/Array/Map
  oneof baseValues {
    IdBaseValue       bId            = 101;
    IntBaseValue      bInt           = 102;
    FloatBaseValue    bFloat         = 104;
    StringBaseValue   bString        = 105;
    EnumBaseValue     bEnum          = 106;
    VectorBaseValue   bVector        = 107;
    StructBaseValue   bStruct        = 108;
    ArrayBaseValue    bArray         = 109;
    ConcreteBaseValue bConcreteValue = 110;
    MapPairBaseValue  bMapPair       = 111;
    MapBaseValue      bMap           = 112;
  }
}

message IdBaseValue { int32 val = 1; }

message IntBaseValue { int32 val = 1; }

message FloatBaseValue { float val = 1; }

message StringBaseValue { string val = 1; }

message EnumBaseValue { int32 val = 1; } // enum.ts/EnumNode_Value

message VectorBaseValue {
  message Vec {
    float x = 1;
    float y = 2;
    float z = 3;
  }
  Vec val = 1;
}

message StructBaseValue { repeated VarBase items = 1; }

message ArrayBaseValue { repeated VarBase entries = 1; }

message MapBaseValue {
  // map pairs should be of Class MapPair
  repeated VarBase mapPairs = 1;
}

message MapPairBaseValue {
  VarBase key   = 1;
  VarBase value = 2;
}

message ConcreteBaseValue {
  // index of concrete node types
  // e.g. EnumNode.EnumEqualList
  int32                       indexOfConcrete = 1;
  VarBase                     value           = 2;
  optional ComplexValueStruct structs         = 5;
}

message ComplexValueStruct { // Map KV, Array Item, Struct Item
  message Base { Wrapper wrapper = 1; }
  message Wrapper {
    VarBase.Class class = 1;
    oneof type {
      VarBase.ItemType.StructItem item    = 100;
      VarBase.ItemType.PairItems  mapPair = 102;
    }
  }
  int32 class = 4;
  Base  inner = 100;
}
// ========== End of Variable Defs ========== //

// ========== Below are Messages that has been refracted ========== //

// 节点图逻辑容器
message NodeGraph {
  // 资源的唯一身份标识
  ResourceLocator identity = 1;
  // 图的友好显示名称
  string display_name = 2;

// --- 执行层 ---
  // 逻辑节点实例列表
  repeated NodeInstance nodes = 3;

  // --- 接口层 ---
  // 接口映射表：定义外部引脚如何穿透到内部节点
  // 仅在作为“复合节点(Composite)”被调用时生效
  repeated InterfaceMapping port_mappings = 4;

  // --- 数据层 ---
  // 局部变量池/黑板变量：存储图内部共享的数据
  repeated GraphVariable blackboard = 6;

  // --- 注释与展示 ---
  repeated Annotation comments = 5;

  // --- 子系统特定参数 ---

  // 入口索引：对应“入口节点”或“外部触发槽位”的索引
  optional int32 entry_slot_index = 100;

  // 轮询/判定频率 (仅用于过滤器)：定义该图逻辑被重新计算的时间间隔
  optional float evaluation_interval = 101;
}

// 注释/文字说明
message Annotation {
  string text = 1;
  // 如果坐标为空，说明该注释是“吸附”在某个节点实例上的（通过 NodeInstance.attached_comment 关联）
  optional float pos_x = 2;
  optional float pos_y = 3;
}

// 节点图变量(黑板变量)
message GraphVariable {
  string var_name = 2;

  // 变量的数据类型定义
  VarType base_type = 3;

  // 变量的初始值/当前值
  VarBase storage_value = 4;

  // 是否暴露为外部可配置参数
  bool is_public = 5;

  // 如果是结构体变量，指向其定义的 ID
  optional int64 schema_ref_id = 6;

  // 容器类型的子类型定义 (残留字段)
  VarType container_key_type   = 7;
  VarType container_value_type = 8;
}

// 接口映射：穿墙管线
message InterfaceMapping {
  // 复合节点外壳上的引脚定义 (对外)
  PinSignature external_port = 1;

  // 映射到的内部目标节点索引 (对内)
  int32 internal_target_node_handle = 2;

  // 映射到的具体内部引脚 (逻辑/物理)
  PinSignature internal_port_shell  = 3;
  PinSignature internal_port_kernel = 4;
}

// 复合节点定义
message NodeInterface {
  // 复合节点的身份标识
  message Signature {
    ResourceLocator shell_ref  = 1;
    ResourceLocator kernel_ref = 2; // 这种生成的节点通常 shell == kernel

    // 关键：对于用户子图，指向内部逻辑图；对于系统生成节点，此字段为空
    ResourceLocator graph_ref      = 4;
    optional int32  signal_version = 5;
  }

  // 参数/数据引脚定义
  message PinDef {
    string       name            = 1;
    int32        visibility_mask = 2; // 原 xxxx_always_1 (位掩码)
    PinSignature sig             = 3; // 包含 Kind (IN_PARAM/OUT_PARAM) 和 Index

    // 引脚类型定义
    message TypeInfo {
      // optional for flow pin
      optional VarBase.Class ui_class        = 1; // UI表现形式 (IntBase, VecBase等)
      optional VarType       var_type_shell  = 3; // VarType 枚举, 对于 Enum, 为 [100id](EnumCategoryId)
      optional VarType       var_type_kernel = 4; // VarType 枚举, 对于 Enum, 为 14(EnumType)

      // 参数框提示文本
      message Placeholder {
        int32  always_1 = 1;
        string text     = 2;
      }
      optional Placeholder placeholder = 5;

      // 元数据引脚特有的显示状态 (如显示为信号名称输入框)
      message DisplayState {
        enum State { NONE = 0; SIGNAL_NAME = 4; }
        State state = 1;
      }
      optional DisplayState display_state = 7;

      oneof detail {
        EnumId   enum_id        = 101;
        ListType list_item_type = 102;
        StructId struct_id      = 104;
        MapType  map_type       = 105;
      }

      message EnumId { int64 val = 1; }
      message ListType {
        TypeInfo item_type = 1;
      }
      message StructId { int64 val = 2; }
      message MapType {
        VarType key   = 3;
        VarType value = 4;
        // if value is StructList
        optional int64 struct_id = 5;
      }
    }

    TypeInfo type = 4;
    // 如果是系统生成的结构体/信号节点，标记其元数据类型
    optional PinSignature meta_sig_type      = 5;
    int32                 persistent_pin_uid = 8;
  }

  // 实现模板定义
  message Implementation {
    enum Category {
      UNKNOWN         = 0;
      COMPOSITE       = 1000; // 用户子图
      SEND_SIGNAL     = 1001; // 发送信号
      LISTEN_SIGNAL   = 1002; // 监听信号
      STRUCT_ASSEMBLY = 1003; // 拼装结构体
      STRUCT_SPLIT    = 1004; // 拆分结构体
      STRUCT_MODIFY   = 1005; // 修改结构体
    }
    Category category = 1;

    message Id { int64 id = 1; }
    message SignalBinding {
      string          signal_name    = 1;
      ResourceLocator server_node_id = 2;
      ResourceLocator client_node_id = 3;
    }

    oneof template {
      // 对应 Send/Listen 的信号信息
      SignalBinding send_signal   = 101;
      SignalBinding listen_signal = 102;
      // 对应 Assembly/Split 的结构体 ID
      Id assemble_struct = 104;
      Id split_struct    = 105;
      Id modify_struct   = 106;
    }
  }

  Signature id = 4;

  repeated PinDef inflows   = 100;
  repeated PinDef outflows  = 101;
  repeated PinDef inputs    = 102;
  repeated PinDef outputs   = 103;
  repeated PinDef meta_pins = 106; // 原 signals，存放 Type 5 引脚

  Implementation impl = 107;

// 这里的 Which 逻辑建议保留原本命名，因为它们是模板系统的索引
  enum TemplateRoot {
    UNKNOWN        = 0;
    SUB_TEMPLATE   = 1;
    LISTEN_SIGNAL  = 2;
    STRUCT         = 5;
    USER_COMPOSITE = 6;
  }
  enum TemplateSub  {
    NONE          = 0;
    MODIFY_STRUCT = 3;
    STRUCT_SUB    = 4;
    SIGNAL_SUB    = 8;
  }

  string       name          = 200;
  string       description   = 201;
  TemplateRoot template_root = 203; // 原 which
  TemplateSub  template_sub  = 204; // 原 subWhich
}

// 节点图中单个节点实例
message NodeInstance {
  // 节点在图中的唯一索引 (运行时句柄)
  int32 index = 1;

  // 核心定义与实现分离

  // 外壳定义(UI): shell_ref: 决定节点长什么样
  ResourceLocator shell_ref = 2;

  // 内核实现(Logic): kernel_ref : 决定节点怎么跑
  // - 对于固定节点: 始终有值。
  // - 对于可变节点:
  //    - 若为 null: 表示"未决议" (Unresolved)。节点处于未配置类型的无效状态。
  //    - 若有值: 表示已根据用户选择的类型，映射到了具体的内核函数 ID。
  // - 对于 Client Skill 入口 (Start): 通常为 Kernel 2001。(Listen)
  // - 对于 Client Skill 执行节点 (Execution): 通常为 Kernel 2000。(POST)
  optional ResourceLocator kernel_ref = 3;

  // 引脚与参数
  repeated PinInstance pins = 4;

  float x_pos = 5;
  float y_pos = 6;

  // 附加在节点上的用户备注
  optional Annotation attached_comment = 7;

  // 特殊上下文标记 (Legacy / Context Provider)

  // 仅出现在入口节点 (NodeGraphStarts, Kernel 2001)
  // 标识该图被触发时的上下文类型 (如 Signal)。
  // 实际是一个无索引的 PinSignature
  optional PinSignature context_declaration = 8;

  // 仅用于 Signal 相关节点，用于检测定义版本冲突
  optional int32 signal_version = 9;

  // 结构体依赖声明
  repeated ResourceLocator using_structs = 10;
}

message PinSignature {
  enum Kind {
    UNKNOWN   = 0;
    IN_FLOW   = 1;
    OUT_FLOW  = 2;
    IN_PARAM  = 3;
    OUT_PARAM = 4;

    // 特殊用途
    META_RPC_OPCODE = 5; // 原 SignalClient. 携带 RPC ID
    META_TOPIC_NAME = 6; // 原 Signal (Entry Context). 携带信号名称/Context声明

    // 结构体操作
    STRUCT_REF        = 13;
    STRUCT_KEY_MOD    = 14;
    STRUCT_KEY_SET    = 15;
    STRUCT_KEY_SELECT = 16;
  }
  Kind  kind  = 1;
  int32 index = 2; // 第几个该类型的引脚

  // 当 kind 为 META_RPC_OPCODE (5) 时存储 RPC ID
  message SignalId { int64 id = 1; }
  optional SignalId source_ref = 100;
}

message PinInstance {

  // 双重索引系统
  PinSignature shell_sig  = 1; // i1: 对应 Shell 定义的 UI 槽位
  PinSignature kernel_sig = 2; // i2: 对应 Kernel 实现的 参数 槽位

  // 值与类型
  VarBase value = 3;
  int32   type  = 4; // Be careful! VarType in Server and ClientVarType in Client

  // 连接关系
  repeated NodeConnection connections = 5;

  // 动态绑定信息

  // 元数据绑定
  // 用于 SendSignal 等节点，存储 RPC ID 或 Topic Name 的绑定关系
  // 原 signalPin
  optional PinSignature binding_meta = 6;

  // 持久化引脚 ID
  // 仅用于动态类型 (Struct/Signal/Composite)
  // 当 Shell 定义发生变更(插队/重排)时，通过此 ID 找回连线关系
  optional int32 persistent_pin_uid = 7; // 原 compositePinUid
}

message NodeConnection {
  int32        target_node_index = 1;
  PinSignature target_pin_shell  = 2;
  PinSignature target_pin_kernel = 3;
}
