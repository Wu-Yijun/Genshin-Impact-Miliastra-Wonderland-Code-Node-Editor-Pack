# 千星奇域编辑器节点行为图 DSL (Domain-Specific Language) 设计规范提案

## 0. 前言 (Introduction)

### 0.1 为什么需要这套 DSL？

在游戏、互动叙事、AI 代理逻辑、仿真系统等领域中，行为逻辑往往以可视化的节点图（Node Graph）形式构建。

节点图具备如下优势：
* **结构直观**：对非程序人员友好，能看到行为流向
* **易于协作**：更适合关卡设计师、策划、数值人员共同编辑
* **模块化强**：复合节点（component）可以像积木一样堆叠
* **限制明确**：图结构天然是无并发、可控顺序、强结构化

但图编辑器也有天然缺点：
* **难以版本管理**（文本 diff 混乱，二进制格式不可读）
* **难以团队同步**（多人同时修改图文件容易冲突）
* **难以代码审查**（PR 无法有效阅读和讨论图结构）
* **可视化与运行时实现往往绑定**（迁移成本高、替换困难）

因此，我们需要一种方式 —— 用纯文本描述图结构，但仍保持图的可读性与结构性。

这正是本 DSL 的目标所在。

它**不是**为了运行时执行，而是为了：
* 纯文本可维护性（diff、merge、review）
* 高亮、结构化、直观
* 可逆（图 ↔ 文本）
* 稳定、无歧义的解析性
* 能承载复杂行为图的所有语义（分支、合流、Switch、选择、多输出、复合节点等）

更重要的是，它要让熟悉编程语言的用户读懂，降低思维负担。

---

### 0.2 这套 DSL 是什么？

本 DSL 是一种 **基于 TypeScript 语法风格的“行为图描述语言”**。

它具有以下特征：
* ✅ **用 TS 可以渲染高亮的代码表达图结构**（Execution Graph）
    例如链式语法 `.Fun1().Fun2()` 表示顺序执行，
    `>> {0: ..., 1: ...}` 表示分支，
    `If(cond)(true = ..., false = ...)` 表示选择节点。
* ✅ **严格定义执行流（控制流）与运算流（数据流）**
    * **控制流**决定行为逻辑执行顺序
    * **运算流**（`$(()=>{})`）描述节点计算逻辑
    * 两者通过变量引用交互
* ✅ **支持组件 Component 作为可重用行为单元**
    * 大写首字母 `function Component` = 带控制流的复合节点
    * 小写首字母 `const lambda` = 纯运算节点
    * Component 内允许存在自己的触发器（作用域为单文件）
* ✅ **设计为“静态描述”而非“运行时执行”**
    DSL 的目标不是运行代码，而是：
    * 用于构建可视化图
    * 用于共享、审查、版本管理
    * 用于转译成运行时格式（JSON/二进制/引擎内部结构）

因此允许使用 TypeScript 写法，但不得混入 TS 的运行时行为。

---

### 0.3 目标与适用范围

本 DSL 的主要目标：
1.  提供完整的行为图静态描述能力
    —— 包括顺序、并行、合流、条件、Switch、多输出、component、临时变量、全局变量等。
2.  保证语义明确、无歧义
    —— 所有变量、作用域、分支编号、Branch id、触发器行为都有严格规范。
3.  具备强可读性与高亮能力
    —— 形似 TypeScript，但实际是一套 DSL。
4.  保证可逆性
    —— 可从 DSL 生成功能等价的节点图
    —— 生成的图可反向转为 DSL，结构一致
5.  具备稳定、可测试的解析难度
    —— 无“隐式语义”、无“魔法语法”，所有行为都是显式的。

---

### 0.4 本 DSL 不是：

* ❌ 不是真正的 TypeScript，也不是脚本语言
* ❌ 不是运行时行为脚本
* ❌ 不是事件驱动引擎本身
* ❌ 不承担真实计算任务（表达式由 `$(...)` 承载）
* ❌ 不允许 TS 标准库或任意函数乱入（如 `Math.random`）

它是一种表达图结构的文本格式。

你可以把它看作：
* ✅ **「行为树/蓝图/节点图的纯文本版」**
* ✅ **「结构化、可读、可 diff 的图描述文件」**
* ✅ **「输入给图编辑器/可视化器/转译器的源语言」**

---

### 0.5 设计哲学（核心理念）

为了让文本能完美描述可视化行为图，我们遵循了三大原则：

**(1) 语法简洁，但行为必须完全可见**
所有控制流必须显式书写：
* 分支必须写 `>> {...}`
* 合流必须写 `.Branch["id"]` 或 `{... >> 0}`
* 选择必须写 `If()` 或 `Switch()`
隐藏行为是不允许的。

---

**(2) 变量命名与作用域必须无歧义**
* 同一触发器执行树下的变量名绝不允许重复
* `$(...)` 引用的变量必须是语义明确的
* 所有变量必须能追溯到唯一来源
* `Branch id` 与 Component 内外的作用域严格隔离
这保证 图结构清晰可控。

---

**(3) 行为图的语义优先于 TypeScript 语义**
* `.Fun1().Fun2()` 不是函数调用链，而是 **节点连接**
* `{ }` 内的多行不是 block，而是 **自动连接的顺序节点**
* `$(()=>{})` 不是 lambda，而是 **运算节点**
* 字面量类型则由 DSL 定义，而不是 TS 的 `number/string/bool`
代码只是载体，真实含义由行为图语义决定。

---

### 0.6 文档结构简介

文档后续章节将依次介绍：
1.  文件结构与模块组织
2.  语法规则与可写结构
3.  控制流与运算流行为语义
4.  变量体系与命名空间
5.  Component 与跨文件机制
6.  错误处理与语义约束
7.  示例图与示例代码
8.  中间表示（IR）与可视化映射
9.  附录（关键字、正则、术语等）

---

## 1. 概览（概念与术语）

### 1.1 节点图核心概念

* **触发器 (Trigger)**：执行流的起点。例如 `[OnCreate()]`, `[Timer("...")]`。
* **执行节点 (Execution Node)**：在控制流上执行具体操作的节点，例如 `.Fun()`。
* **运算节点 (Data Node)**：在运算流上执行纯计算的节点，使用 `$(...)` 语法定义。
* **复合节点 (Component)**：封装了一组执行节点和/或运算节点的子图，可被复用。
* **分支锚点 (Branch Anchor)**：用于标记控制流的特定位置，以便其他分支跳转或合并，使用 `.Branch["id"]` 或 `Branch["id"].` 定义。

### 1.2 控制流 vs 运算流

* **控制流 (Control Flow)**：
    * **定义**：描述行为执行的顺序、分支、选择和合并。
    * **表示**：由 `[Trigger]` 开始，通过 `.`、`>>`、`If()`、`Switch()`、`>> {}` 等语法连接的执行节点链。
    * **特性**：控制流是图的主干，决定了哪些节点会被激活以及激活的顺序。
* **运算流 (Data Flow)**：
    * **定义**：描述节点所需数据的计算过程。
    * **表示**：使用 `$(...)` 语法定义，附加在执行节点上，或作为函数参数。
    * **特性**：运算流是被动求值的。只有当控制流激活了某个执行节点时，该节点所需的运算流才会被（实时）计算。

### 1.3 图的基本约束

* **无环 (Acyclic)**：图中不允许出现控制流或运算流的循环。任何循环的出现都应被视为编译时错误。
* **单线程 (Single-Threaded)**：所有执行均被视为在单个线程上按严格顺序发生，无并发或竞态条件。
* **深度优先 (Depth-First)**：并行分支（`>> {}`）和组件出口（`Out()`）的执行遵循严格的深度优先顺序。

## 2. 文件与模块组织

### 2.1 单文件图 (Graph Module)

* **文件级语义**：一个 `.ts` 文件（建议使用 `.graph.ts` 等特定后缀）对应一个完整的、独立的节点图（Graph Module）。
* **执行流隔离**：控制流严格限制在单个文件内，不允许跨文件跳转、分支或合并。

### 2.2 文件头部声明

文件顶部（或 `Component` 内部）用于定义该图所需的类型、全局状态和临时变量：

* **导入 (Imports)**：`import { MyComponent, MyStruct } from "./other_graph"`。
* **结构体 (Structs)**：`interface MyStruct { a: int, b: string }`。
* **全局计时器 (Timers)**：`declare class Timer { my_timer: CountDown = 5 }`。
* **全局信号 (Signals)**：`declare class Signal { MySignal(a: int) }`。
* **全局变量 (Global)**：`declare class This { val: float = 1.0 }`。
* **节点图变量 (Node)**：`declare class node { config_list: List<Config> = [] }`。
* **临时变量 (Temporary)**：`const _temp_val: int = 0`。

### 2.3 跨文件规则

* **允许导入**：可以导入其他文件定义的 `Component`（复合节点）、`const`（纯运算函数）、`interface`（结构体）以及 `declare` 声明。
* **隔离执行**：导入 `Component` 只是导入了其*模板定义*。调用该 `Component` 时，它将在*当前*文件的图上下文中实例化并执行。

## 3. 语法概要（用户可写的约定语法）

### 3.1 触发器语法

执行流的起点，必须顶格书写。

* `[OnCreate()]`
* `[OnDestroy()[self]]` (带输出变量)
* `[Timer("count_down")]`
* `[Signal("Add")[a, b]]` (带输出参数)

### 3.2 顺序链与方法调用链

* `.Fun1().Fun2()`：表示 `Fun1` 执行完毕后，自动连接到 `Fun2`。
* `>> Fun1() >> Fun2()`：与 `.` 链在顺序执行中等价。

### 3.3 分支（并行）语法

使用 `>>` 符号后跟 `{}` 块表示并行分支。

* `...FunA() >> { 0: FunB(), 1: FunC() }`
* **规则**：分支键必须是**整数字面量**，并按升序（0, 1, 2...）决定深度优先的执行顺序。

### 3.4 合流（跳转）语法

* **锚点定义 (A型)**：`Branch["id"].FunX()` (定义一个新链的起点)
* **锚点定义 (B型)**：`.FunY().Branch["id"]` (在 `FunY` 之后标记一个锚点)
* **跳转**：`.FunZ() >> "id"` (执行完 `FunZ` 后，跳转到 "id" 锚点)
* **块内合流**：`>> { 0: FunB() >> 0, 1: FunC() >> 0 }`
    * `>> 0` 是特殊语法，表示“合并回 `>> {}` 块*之后*的主干流”。

### 3.5 选择语法 (If / Switch)

* `If(cond)(true = ..., false = ...)`
* `Switch(val)(lit1 = ..., lit2 = ..., null = ...)` ( `null` 为
    default 分支)
* **规则**：`Switch` 的分支键必须是字面量（整数、字符串、布尔值）。
* **省略语法 (语法糖)**：
    * `If(cond).FunX()` 严格等价于 `If(cond)(true = 0, false = null).FunX()`。
    * `Switch(val).FunX()` 严格等价于 `Switch(val)(null = 0).FunX()`。(解析器应在此处发出警告，提示缺少显式分支)。

### 3.6 复合节点（Component）定义

* **含控制流**：`function ComponentName(a: int) { ... return [...]("exit") }` (首字母大写)
* **纯运算**：`const funcName = (a: int): int => { ... }` (首字母小写)

### 3.7 运算 ($) 语法

* **单输出**：`.$((a) => a + 1)[out_val]`
* **多输出映射**：`.$((a,b) => { return {x: a+b, y: a-b} })[val_x = x, val_y = y]`
* **捕获列表**：`$( (a,b) => ... )` 中的 `(a,b)` 是*必须*详尽列出的**依赖捕获列表**。

### 3.8 临时变量与 SetVal

* **声明**：`const _x: int = 0` (必须在文件顶层或 Component 顶层)
* **修改**：`.SetVal(_x, new_val)`。`SetVal` 也可用于修改 `this.val` 或 `node.val`。

### 3.9 Branch id 格式

Branch id 必须是**字面量**（字符串、整数或布尔值），使用时如 `Branch[0]` 或 `Branch["MyBranch"]`。建议使用字符串字面量以增强可读性。

## 4. 类型系统与命名约定

### 4.1 字面类型集

`int`, `float`, `boolean`, `string`, `vec`, `Entity`, `GUID`, `Prefab`, `Config`, `List<T>`, `Dict<K,V>`,以及用户定义的 `interface` (Structs)。

### 4.2 命名空间

系统定义了四个严格隔离的命名空间。不同空间内的同名变量**不会**冲突。

1.  **`function outputs` (函数输出)**：
    * 来源：`[Trigger()[a]]`, `.Fun()[b]`, `$(...)[c]`
    * 特性：只读。
2.  **`global (this)` (全局变量)**：
    * 来源：`declare class This { ... }`
    * 特性：持久化，可读写。
3.  **`node vars (node)` (节点图变量)**：
    * 来源：`declare class node { ... }`
    * 特性：持久化（图单例），可读写。
4.  **`temporary (_x)` (临时变量)**：
    * 来源：`const _x: int = ...`
    * 特性：单次触发树生命周期，可读写。

### 4.3 唯一性约束

* **`function output`**：变量名（即别名，如 `[my_var = out]` 中的 `my_var`）在**同一触发器执行树**内必须是唯一的。
    * `[OnCreate()].Fun1()[a]` 和 `[OnCreate()].Fun2()[a]` 是**非法**的（`a` 重复）。
    * `[OnCreate()].Fun1()[a]` 和 `[OnDestroy()].Fun2()[a]` 是**合法**的（不同触发器树）。
    * `[OnCreate()].Fun1()[a = out1]` 和 `[OnCreate()].Fun2()[b = out1]` 是**合法**的（外部别名 `a` 和 `b` 不同）。
* **`Branch id`**：在**同一作用域**（文件顶层或 Component 内部）内必须是唯一的。
    * 在文件中定义 `Branch["MyBranch"]` 和 `.Fun().Branch["MyBranch"]` 是**非法**的（重复定义）。

## 5. 控制流语义（详细）

### 5.1 触发器

触发器是执行流的唯一入口。位于 `Component` 内部的触发器会被注册到文件级的图实例上。

### 5.2 顺序链

在同一 `>> {}` 块、`If/Switch` 分支或顶层链中，按 `.Fun()` 或 `>> Fun()` 书写的节点按顺序自动连接。

### 5.3 并行分支 ( `>> {...}` )

* `>> {...}` 块中的所有分支均被视为“并行”执行（尽管在单线程中是顺序的）。
* **执行顺序**：严格按照分支键（Key）的**整数字面量升序**，进行**深度优先**执行。
    * 在 `>> { 1: FunC(), 0: FunB() }` 中，`FunB()` (key 0) 所在的链会先于 `FunC()` (key 1) 所在的链执行。

### 5.4 多入节点语义

* **规则**：当多条控制流边（来自并行分支或 `>> "id"` 跳转）汇入同一个节点时，该节点将被**激活多次**，每条入边到达时触发一次。
* **无自动合并**：节点本身不具备“等待所有输入”的逻辑；它们是即时触发的。

### 5.5 合流语义

* **`>> 0` (块合流)**：
    * 用于 `>> {}` 或 `If/Switch` 块内部。
    * 语义：执行流跳转到该块*之后*的第一个主干节点。
    * 边界情况：如果块之后没有主干节点（即语句结束），`>> 0` 是一个有效的“空操作”（等同于 `>> null`），但解析器可发出警告。
* **`Branch["id"]` (锚点合流)**：
    * `Branch["id"].FunX()` 或 `.FunY().Branch["id"]` 用于**定义**一个锚点。
    * `.FunZ() >> "id"` 用于**跳转**到该锚点。
    * **错误**：重复定义 `Branch` id 或 `>> "id"` 到一个不存在的 id 都是编译时错误。

### 5.6 If / Switch 选择语义

* **单一分支**：`If` 和 `Switch` 保证只有一条控制流路径会被执行。
* **分支键**：`Switch` 的键必须是字面量，不能是变量。

### 5.7 链式与延迟执行操作符 (>> vs <<)

* **`>>` (顺序链)**：
    * 语义：`A >> B >> C` 等价于 `A.B.C`。
    * 执行顺序：A 执行完毕 -> B 执行完毕 -> C 执行完毕。
    * 等价展开：`A >> {0: B, 1: 0()}.C`。
* **`<<` (延迟/挂起执行)**：
    * 语义：`A << B >> C...` 表示在 A 执行后，先执行 C 及其后续的所有内容，待 C 的整条链路完全结束后，再回过头来执行 B。
    * 等价展开：`A >> {0: 0(), 1: B}.C...` (注意：此处 B 位于分支 1，而 C 接在分支 0 的合流之后，但根据定义，`<<` 隐含了 B 是在 C *之后* 执行的逆序逻辑，或者更准确地说是“挂起 B，先走主干 C”)。
    * **多重挂起**：当链上有多个 `<<` 时（如 `A << B << C >> D`），执行顺序为：先执行主干 `D`，待 `D` 结束后执行 `C`，待 `C` 结束后执行 `B`。即“后挂起的先执行”（栈式行为）或“从后向前依次执行被挂起的节点”。

## 6. 运算流语义 (详细)

### 6.1 `$(...)` 定义与求值

* `$(...)` 是创建运算流节点的唯一方式。
* **求值时机**：运算节点在它所依附的**执行节点被控制流激活时**，才会被实时求值。

### 6.2 `$(...)` 依赖与捕获

* **捕获列表**：`$( (a,b) => ... )` 中的 `(a,b)` 是**强制性**的依赖捕获列表。
* **规则 1 (详尽列出)**：`$(...)` 内部使用的所有 `function output` 变量，**必须**在捕获列表中声明。
* **规则 2 (例外)**：`this.*`, `node.*` 和 `_x` 变量不需要（也不应该）在捕获列表中声明，它们可被直接访问。
* **错误 (阻断)**：
    * `.$((a) => a + b)` —— `b` 未在捕获列表 `(a)` 中，编译时错误。
    * `.$(() => a)` —— `a` 未在捕为 `()` 的捕获列表中，编译时错误。
* **规则 3 (默认值)**：
    * 如果一个变量 `x` *已在*捕获列表（如 `.$((x) => ...)`），但 `x` 来源于一个尚未执行的 `If/Switch` 分支，此时引用 `x` **不会报错**。
    * `x` 将返回其类型的默认值（`0`, `false`, `""` 等）。

### 6.3 多次调用语义

* 如果两个*不同*的执行节点（如 `FunA` 和 `FunB`）都依赖了同一个运算节点（或 `const` 纯函数），该运算节点将在 `FunA` 激活时求值一次，并在 `FunB` 激活时*再次*求值。
* 在*单个*执行节点内，即使多个入参依赖同一个运算节点，该运算节点也只求值一次。

## 7. 变量与生命周期

本 DSL 包含四类严格区分的变量命名空间：

### 7.1 `function outputs` (函数/节点输出)

* **来源**：`[Trigger()[a]]`, `.Fun()[b]`, `$(...)[c]`。
* **生命周期**：在“同一触发器执行树”内有效。
* **语义**：**只读**。一旦被创建，其值在当前执行树中不可变。
* **约束**：在同一触发器树中，其（别名）名称必须唯一。

### 7.2 `global (this)` (全局变量)

* **来源**：`declare class This { val: int = 0 }`。
* **生命周期**：**持久化**。跨越所有触发器，与挂载实例绑定。
* **语义**：**可读写**。通过 `.SetVal(this.val, ...)` 修改。

### 7.3 `node vars (node)` (节点图变量)

* **来源**：`declare class node { list: List<int> = [] }`。
* **生命周期**：**持久化**。作为图的单例存在，被所有实例共享。
* **语义**：**可读写**。通过 `.SetVal(node.list, ...)` 修改。

### 7.4 `temporary (_x)` (临时变量)

* **来源**：`const _x: int = 0`。
* **生命周期**：**单次触发**。在每次触发器被激活时创建（或重置为初始值），在执行树结束时销毁。
* **语义**：**可读写**。用于在同一执行树中的不同节点间传递可变状态。通过 `.SetVal(_x, ...)` 修改。

## 8. 复合节点 (Component) 语义

### 8.1 定义与调用

* `function ComponentName(...)` (首字母大写)：定义一个包含控制流的复合节点。
* `const funcName = (...)` (首字母小写)：定义一个纯运算函数，只能在 `$(...)` 内部或执行节点参数中调用。

### 8.2 内部触发器

Component 内部允许定义触发器（如 `[OnCreate()]`）。这些触发器被视为注册在*文件级*的图上，而非 Component 实例上。

### 8.3 作用域隔离

* **`Branch id` 隔离**：Component 内部定义的 `Branch["id"]` 对外部不可见。外部也无法 `>> "id"` 跳转到 Component 内部。

### 8.4 执行与出口语义

* **`return` (声明)**：`return [out_val] ("exit1", "exit2")` 用于*声明*该 Component 合法的控制流出口 ID 列表。
* **`Out(id)` (触发)**：在 Component 内部调用 `.Out("exit1")` 会触发对应的出口。
* **错误 (阻断)**：调用 `.Out("invalid_id")`，如果 `"invalid_id"` 不在 `return` 声明的列表中，将导致编译时错误。
* **执行时序 (深度优先)**：
    * 当 `.Out("exit")` 被调用时，控制流*立即*跳转到外部调用处连接到 `"exit"` 分支的节点（如 `FunC`）。
    * 在外部 `"exit"` 分支执行完毕后，控制流**返回**到 Component 内部，继续执行 `.Out()` *之后*的节点（如 `FunB`）。
    * *示例*：内部 `FunA().Out("exit").FunB()`，外部 `Comp()("exit" = FunC())`。执行顺序为 `FunA -> FunC -> FunB`。

## 9. 跨文件规则与模块化

* **执行流隔离**：控制流不能跨越文件边界。
* **导入模板**：`import { MyComponent }` 导入的是模板定义。
* **本地实例化**：调用导入的 `MyComponent()` 时，它将在*当前*文件的上下文中实例化并执行。其内部定义的 `Branch id` 仍受其自身定义的隔离约束。

## 10. 错误/警告策略 (实现建议)

### 10.1 错误 (阻断)

* **命名冲突**：
    * `function output` 别名在同一触发器树中重名。
    * `Branch id` 在同一作用域中重复定义。
* **依赖/引用失败**：
    * `$(...)` 中引用了未在捕获列表中声明的 `function output`。
    * `>> "id"` 跳转到未定义的 `Branch id`。
    * `Out("id")` 触发了未在 `return` 中声明的出口。
* **结构错误**：
    * 检测到控制流或数据流循环。
    * `Switch` 使用了非字面量作为分支键。
* **非法使用**：
    * 在 `$(...)` 之外调用纯运算函数 (`const funcName`)。
    * 在 `$(...)` 内部调用含控制流的 `Component` (`function ComponentName`)。

### 10.2 警告 (允许，但提示)

* `Switch(val).FunX()`：使用了省略语法的 `Switch`，导致只有 `null` (default) 分支会执行后续主干。
* `>> 0`：在 `>> {}` 或 `If/Switch` 块末尾使用，但其后没有主干流可合并。

---

## 11. 示例与片段

### 11.1 单路径顺序流
(示例代码留空)

### 11.2 多分支并行与合流
(示例代码留空)

### 11.3 Switch/If 示例
(示例代码留空)

### 11.4 component 内含触发器示例
(示例代码留空)

### 11.5 临时变量与 SetVal 示例
(示例代码留空)

### 11.6 $() 多输出示例
(示例代码留空)

---

## 12. 中间表示 (IR) 建议 (紧凑)

* **GraphModule**：文件级容器，包含所有 Triggers, Components, 和 Declarations。
* **TriggerNode**：执行流起点。
* **ExecNode**：执行节点 (e.g., `FunA`)。
* **DataNode/EvalNode**：运算节点 (e.g., `$(...)`)。
* **Edge (Control/Data)**：显式连接的边。
* **BranchAnchor**：`Branch["id"]` 的 IR 表示，作为跳转目标。
* **ComponentTemplate**：`function ComponentName` 的定义。
* **ComponentInstance**：`ComponentName()` 的调用实例。
* **SymbolTable/VariableSymbol**：用于管理四个命名空间，并在解析时检查唯一性和依赖。
* **Merge/Select Nodes**：显式的 IR 节点用于表示 `>> {}`（并行）和 `If/Switch`（选择）的逻辑。

---

## 13. 可视化 & 逆向映射 (留档)

### 13.1 从代码到图

* `.FunA().FunB()` 映射为 `[Node A] -> [Node B]`。
* `.FunA() >> { 0: FunB(), 1: FunC() }` 映射为 `[Node A]` 分叉到 `[Node B]` 和 `[Node C]`。
* `.FunA() >> "id"` 和 `Branch["id"].FunB()` 映射为从 `[Node A]` 到 `[Node B]` 的显式跳转边。
* `$(...)` 节点应可视化为依附于其执行节点的数据源。

### 13.2 从图到代码

* **挑战**：保持 `Branch id` 的稳定性和可读性是“往返 (Round-trip)”的关键。
* **建议**：编辑器在保存为图的二进制格式时，应保留（或自动生成）用于合流的 `Branch id`，以便在逆向转译回 DSL 时能恢复结构。

---

## 14. 附录

### 14.1 关键字汇总
(留空，待填充)

### 14.2 字面量 & 正则约束
(留空，待填充)

### 14.3 错误码/警告码列表（草案）
(留空，待填充)

### 14.4 术语表
(留空，待填充)