# 千星奇域编辑器节点行为图 DSL (Domain-Specific Language) 设计规范纲要
<!-- @Version: 1.0.0 -->
<!-- @Author: Aluria -->

## 0. 前言 (Introduction)

### 0.1 为什么需要这套 DSL？

在游戏、互动叙事、AI 代理逻辑、仿真系统等领域中，行为逻辑往往以可视化的节点图（Node Graph）形式构建。

节点图具备如下优势：
* **结构直观**：对非程序人员友好，能看到行为流向
* **易于协作**：更适合关卡设计师、策划、数值人员共同编辑
* **模块化强**：复合节点（component）可以像积木一样堆叠
* **限制明确**：图结构天然是无并发、可控顺序、强结构化

但图编辑器也有天然缺点：
* **难以版本管理**（文本 diff 混乱，二进制格式不可读）
* **难以团队同步**（多人同时修改图文件容易冲突）
* **难以代码审查**（PR 无法有效阅读和讨论图结构）
* **可视化与运行时实现往往绑定**（迁移成本高、替换困难）

因此，我们需要一种方式 —— 用纯文本描述图结构，但仍保持图的可读性与结构性。

这正是本 DSL 的目标所在。

它是为了：
* 纯文本可维护性（diff、merge、review）
* 高亮、结构化、直观
* 可逆（图 ↔ 文本）
* 稳定、无歧义的解析性
* 能承载复杂行为图的所有语义（分支、合流、Switch、选择、多输出、复合节点等）
* 提供本地运行测试

更重要的是，它要让熟悉编程语言的用户读懂，降低思维负担。

---

### 0.2 这套 DSL 是什么？

本 DSL 是一种 **基于 TypeScript 语法风格的“行为图描述语言”**。

它具有以下特征：
* ✅ **用 TS 可以渲染高亮的代码表达图结构**（Execution Graph）
    例如链式语法 `.Fun1().Fun2()` 表示顺序执行，
    `>> {0: ..., 1: ...}` 表示分支，
    `If(cond)(true = ..., false = ...)` 表示选择节点。
* ✅ **严格定义执行流（控制流）与运算流（数据流）**
    * **控制流**决定行为逻辑执行顺序
    * **运算流**（`$(()=>{})`）描述节点计算逻辑
    * 两者通过变量引用交互
* ✅ **支持组件 Component 作为可重用行为单元**
    * 大写首字母 `function Component` = 带控制流的复合节点
    * 小写首字母 `const lambda` = 纯运算节点
    * Component 内允许存在自己的触发器（作用域为单文件）
* ✅ **设计为“静态描述”而非“运行时执行”**
    DSL 的目标不是运行代码，而是：
    * 用于构建可视化图
    * 用于共享、审查、版本管理
    * 用于转译成运行时格式（JSON/二进制/引擎内部结构）

因此在求值时允许使用 TypeScript 写法，但不得混入 TS 的运行时行为。

---

### 0.3 目标与适用范围

本 DSL 的主要目标：
1.  提供完整的行为图静态描述能力
    —— 包括顺序、并行、合流、条件、Switch、多输出、component、临时变量、全局变量等。
2.  保证语义明确、无歧义
    —— 所有变量、作用域、分支编号、Branch id、触发器行为都有严格规范。
3.  具备强可读性与高亮能力
    —— 形似 TypeScript，但实际是一套 DSL。
4.  保证可逆性
    —— 可从 DSL 生成功能等价的节点图
    —— 生成的图可反向转为 DSL，结构一致
5.  具备稳定、可测试的解析难度
    —— 无“隐式语义”、无“魔法语法”，所有行为都是显式的。

---

### 0.4 本 DSL 不是：

* ❌ 不是真正的 TypeScript，也不是脚本语言
* ❌ 不是运行时行为脚本
* ❌ 不是事件驱动引擎本身
* ❌ 不承担真实计算任务（表达式由 `$(...)` 承载）
* ❌ 不允许 TS 标准库或任意函数乱入（如 `Math.random`）

它是一种表达图结构的文本格式。

你可以把它看作：
* ✅ **「行为树/蓝图/节点图的纯文本版」**
* ✅ **「结构化、可读、可 diff 的图描述文件」**
* ✅ **「输入给图编辑器/可视化器/转译器的源语言」**

---

### 0.5 设计哲学（核心理念）

为了让文本能完美描述可视化行为图，我们遵循了三大原则：

**(1) 语法简洁，但行为必须完全可见**
所有控制流必须显式书写：
* 分支必须写 `>> {...}`
* 合流必须写 `{... >> 0()}`
* 选择必须写 `If()` 或 `Switch()`
隐藏行为是不允许的。

---

**(2) 变量命名与作用域必须无歧义**
* 同一触发器执行树下的变量名绝不允许重复
* `$(...)` 引用的变量必须是语义明确的
* 所有变量必须能追溯到唯一来源
* `Branch id` 与 Component 内外的作用域严格隔离
这保证 图结构清晰可控。

---

**(3) 行为图的语义优先于 TypeScript 语义**
* `.Fun1().Fun2()` 不是函数调用链，而是 **节点连接**
* `{ }` 内的多行不是 block，而是 **自动连接的顺序节点**
* `$(()=>{})` 不是 lambda，而是 **运算节点**
* 字面量类型则由 DSL 封装，而不是 TS 的 `number/string/bool`
代码只是载体，真实含义由行为图语义决定。

**(4) 代码字面传达的逻辑与运行逻辑一致**
* 在尽可能简洁的语法下，代码阅读顺序与符号样式是顺直觉的
* 在不熟悉完整语法的前提下, 可以通过阅读代码字面含义来推测运行逻辑

---

### 0.6 文档结构简介

文档后续章节将依次介绍：
1.  文件结构与模块组织
2.  语法规则与可写结构
3.  控制流与运算流行为语义
4.  变量体系与命名空间
5.  Component 与跨文件机制
6.  错误处理与语义约束
7.  示例图与示例代码
8.  中间表示（IR）与可视化映射
9.  附录（关键字、正则、术语等）

---

## 1. 概览（概念与术语）

### 1.1 节点图核心概念

* **触发器 (Trigger)**：执行流的起点。例如 `[OnCreate()]`, `[Timer("...")]`。
* **执行节点 (Execution Node)**：在控制流上执行具体操作的节点，例如 `.Fun()`。
* **运算节点 (Data Node)**：在运算流上执行纯计算的节点，使用 `$(...)` 语法定义。
* **复合节点 (Component)**：封装了一组执行节点和/或运算节点的子图，可被复用。
* **分支锚点 (Branch Anchor)**：用于标记控制流的特定位置，以便其他分支跳转或合并，使用 `Branch["id"]` 定义。

### 1.2 控制流 vs 运算流

* **控制流 (Control Flow)**：
    * **定义**：描述行为执行的顺序、分支、选择和合并。
    * **表示**：由 `[Trigger]` 开始，通过 `.`、`>>`、`If()`、`Switch()`、`>> {}` 等语法连接的执行节点链。
    * **特性**：控制流是图的主干，决定了哪些节点会被激活以及激活的顺序。
* **运算流 (Data Flow)**：
    * **定义**：描述节点所需数据的计算过程。
    * **表示**：使用 `$(...)` 语法定义，附加在执行节点上，或作为函数参数。
    * **特性**：运算流是被动求值的。只有当控制流激活了某个执行节点时，该节点所需的运算流才会被（实时）计算。

### 1.3 图的基本约束

* **无环 (Acyclic)**：图中不允许出现控制流或运算流的循环。任何循环的出现都应被视为编译时错误。
* **单线程 (Single-Threaded)**：所有执行均被视为在单个线程上按严格顺序发生，无并发或竞态条件。
* **深度优先 (Depth-First)**：并行分支（`>> {}`）和组件出口（`Out()`）的执行遵循严格的深度优先顺序。

## 2. 文件与模块组织

### 2.1 单文件图 (Graph Module)

* **文件级语义**：一个 `.ts` 文件（建议使用 `.graph.ts` 等特定后缀）对应一个完整的、独立的节点图（Graph Module）。
* **执行流隔离**：控制流严格限制在单个文件内，不允许跨文件跳转、分支或合并。

### 2.2 文件头部声明

通常在文件顶部定义该图所需的函数、结构体、全局状态和临时变量：

* **导入全局环境 (Env)**：`import "./global_env.d.ts"`。
* **导入函数 (Imports)**：`import { my_add, MyComponent } from "./other_graph.ts"`。
* **全局结构体 (Structs)**：`declare global{ interface MyStruct { a: int, b: string }}`。
* **全局计时器 (Timers)**：`declare global{ namespace Timer { const MyTimer: CountDown<5>; }}`。
* **全局信号 (Signals)**：`declare global{ namespace Signal { function MySignal(a: int): Signal; }}`。
* **全局实体变量 (Self)**：`declare global{ namespace Self { const val: float = 1; }}`。
* **节点图变量 (Node)**：`declare namespace node { const config_list: List; }`。
* **临时变量 (Temporary)**：`const _temp_val: int = 0n`。
* **组件 (Component)**：`function MyComponent(arg1: int) { ... return ExecFunc<{ ret_args }>(); }`。
* **求值函数 (Lambda)**：`const my_calc_fun = (arg1: int) = > { ... };`。

核心设计理念为, 不同功能性的定义用不同的形式表示, 大写代表全局的和执行节点, 小写和下划线对应局部的和纯运算, 
同时保证不同作用域的定义在 TS 语法下可以适用于该作用域. 我们在 declare global 内定义的项目, 在 TS 语法中也是跨文件的.

### 2.3 跨文件规则

* **导入**：可以导入其他文件定义的 `Component`（复合节点）、`const`（纯运算函数）。
* **隔离执行**：导入 `Component` 只是导入了其*模板定义*。调用该 `Component` 时，它将在*当前*文件的图上下文中实例化并执行。

## 3. 语法概要（用户可写的约定语法）

### 3.1 触发器语法

执行流的起点，必须顶格书写, 并用方括号包裹触发器。

* `[OnCreate()]`
* `[OnDestroy()[target]]` (带输出变量)
* `[Timer(Timer.MyTimer)]`
* `[Signal(Signal.MySignal)[a, b]]` (带输出参数)

### 3.2 顺序链与方法调用链

* `.X().Y().Z()...`：表示 `X` 执行完毕后，自动连接到 `Y`，依此类推。
* `X() >> Y() >> Z()`：与 `.` 链在顺序执行中等价。
* `X() << Y() >> Z()`：表示将 `Z()` 挂起, 先执行 `Z()` 及后续方法。

设计理念：核心是用 `.` 表示的调用链; 为保证 `{}` 在调用链中的类型合法, 引入了 `>>` 操作;
挂起操作较为反直觉的, 一般没有使用场景, 但组件的控制流出口遵循最后执行的逻辑, 为保证一致性引入了最后执行的 `<<` 操作.

### 3.3 分支（并行）语法

使用 `>>` 符号后跟 `{}` 块表示并行分支, 单线程运行时决定了它是有序依次执行的。

* `...X() >> { 0: Y(), 1: Z() }`
* **规则**：分支键必须是**数字字面量**，并按升序（0, 1, 2...）决定深度优先的执行顺序。

### 3.4 合流（跳转）语法

* **锚点定义 (触发器样式)**：`Branch["id"].X()` (定义一个新链的起点)
* **锚点定义 (链内部样式)**：`.Y().Branch["id"].Z()` (在 `Y` 之后标记一个锚点)
* **跳转**：`.Z() >> "id"()` (执行完 `Z` 后，跳转到 "id" 锚点)
* **块内合流**：`>> { 0: X() >> 0(), 1: Y() >> -1(), 2: Z() >> 1(), 3: W() >> "id"() }`
    * `>> 0()` 是特殊语法，表示“合并回 `>> {}` 块*之后*的主干流”。
    * `>> -1()` 是特殊语法，表示“Do nothing”, 出于一致性原则设计。
    * `>> 1()` 与 `>> "id"()` 均无特殊性, 表示执行用户定义的锚点.

设计理念: 在字面量后加括号构成函数的样式, 在直觉上的行为是函数调用: 先执行内部逻辑, 再返回执行后续节点.

### 3.5 选择语法 (If / Switch)

* `If(cond)(true = ..., false = ...)`
* `Switch(val)(lit1 = ..., lit2 = ..., null = ...)` ( `null` 为
    default 分支)
* **规则**：`Switch` 的分支键必须是字面量（整数、字符串、布尔值）。
* **省略语法 (语法糖)**：
    * `If(cond).X()` 严格等价于 `If(cond)(true = 0(), false = -1()).X()`。
    * `Switch(val).X()` 严格等价于 `Switch(val)(null = 0()).X()`。(解析器应在此处发出警告，提示缺少显式分支)。

设计理念：花括号字典有较好的顺序性, 且无法直接连接在函数后, 因此分配给分支语法; 方括号被输出变量占了, 复用容易产生歧义;
圆括号与函数执行联系紧密, 作为选择语法较为合适, 且与花括号字典有较好的区分度.
大多数选择语法只使用单一的分支, 省略语法将默认 If 分支设置为 true, 保持了阅读的一致性.
Switch 分支如有默认行为, 在阅读代码时容易产生歧义, 将其设为未定义行为.

### 3.6 复合节点（Component）定义

* **含控制流**：`function ComponentName(a: int) { ... return ExecFunc<{ ret_args }>() }` (首字母大写)
* **纯运算**：`const func_name = (a: int): int => { ... }` (首字母小写, 下划线连接)

通过函数和闭包的形式在定义处明显区分控制流和运算, 命名规范的显著差异有助于区分编辑器补全函数.

### 3.7 运算 ($) 语法

* **单输出**：`.$((a) => a + 1)[out_val]`
* **多输出**：`.$((a,b) => { return [a+b, a-b]; })[s, t]`
* **多输出映射**：`.$((a,b) => { return {x: a*b, y: a/b} })[val_x = x, val_y = y]`
* **捕获列表**：`$( (a,b) => ... )` 中的 `(a,b)` 是*必须*完整列出的**函数输出变量依赖列表**。

设计理念: 在整个DSL中，函数输出的声明和命名是最随意和不易观察的, 因此强制用户列出函数输出依赖; 
这有助于检查遗漏和重复定义, 也增强了代码上下文可读性.

### 3.8 临时变量与 SetVal

* **声明**：`const _x: int = 0n;` (必须在文件顶层或 Component 顶层)
* **修改**：`.SetVal(_x, new_val)`。`SetVal` 也可用于修改 `Self.val` 或 `node.val`。

设计理念: 大量系统函数的函数名被设置为一致的, 仅通过函数签名重载区分, 通过运行时动态判断类型.
相似功能的函数也可被设置为同一个函数, 引入额外的参数控制行为.
不应要让用户记住大量函数名, 或在大量的补全提示列表中寻找, 而是先写出函数, 在通过函数签名决定要输入什么.

### 3.9 锚点 Branch id 格式

Branch id 必须是**字面量**（字符串、正整数），通过 `Branch[100]` 或 `Branch["MyBranch"]` 标记锚点。建议使用字符串字面量以增强可读性。

设计理念: 为数不多的`变量名+方括号`, 另外一处是触发器用方括号包裹, 这也是为了增强视觉显著性, 便于查找对应锚点.

## 4. 类型系统与命名约定

### 4.1 字面类型集

`Int`, `Float`, `Bool`, `Str`, `Vec`, `Entity`, `GUID`, `Prefab`, `ConfigId`, `Faction`, `List`, `Dict`, 以及用户定义的 `Struct`。
这些类型以类封装了数值, 均是 `SysTypeBase` 类的派生类。为减少创建基本类型的字面量值的样板代码, 用基本类型 `int`, `float`, `bool`, `str` (对应`bigint/number/boolean/string`) 作为字面量和基本派生类的等价表示。

### 4.2 命名空间

系统定义了四个严格隔离的命名空间。不同空间内的同名变量**不会**冲突, 临时变量必须以 `_` 前缀命名。

1.  **`function outputs` (函数输出)**：
    * 来源：`[Trigger()[a]]`, `.Fun()[b]`, `$(...)[c]`
    * 特性：只读。
2.  **`global (Self)` (全局变量)**：
    * 来源：`namespace Self { ... }`
    * 特性：持久化，可通过 SetVal 赋值。
3.  **`node vars (node)` (节点图变量)**：
    * 来源：`namespace node { ... }`
    * 特性：持久化（图单例）, 可通过 SetVal 赋值。
4.  **`temporary (_x)` (临时变量)**：
    * 来源：`const _x: int = ...`
    * 特性：单次触发树生命周期, 可通过 SetVal 赋值。

### 4.3 唯一性约束

* **`function output`**：变量名（即别名，如 `[x = out]` 中的 `x`）在**同一触发器执行树**内必须是唯一的。
    * `[OnCreate()].X()[a]` 和 `[OnCreate()].Y()[a]` 是**非法**的（`a` 重复）。
    * `[OnCreate()].X()[a]` 和 `[OnDestroy()].Y()[a]` 是**合法**的（不同触发器树）。
    * `[OnCreate()].Z()[a = out]` 和 `[OnCreate()].Z()[b = out]` 是**合法**的（外部别名 `a` 和 `b` 不同即可）。
* **`Branch id`**：在**同一作用域**（文件顶层或 Component 内部）内必须是唯一的。
    * 在文件中定义 `Branch["MyBranch"]` 和 `.Fun().Branch["MyBranch"]` 是**非法**的（重复定义）。

设计理念: 节点图是DAG, 但分支行为导致数据引用可能交叉: `If(i)(true="A"()>>"B"(), false="B"()>>"A"()); Branch["A"].X()[x]; Branch["B"].Y(x)[y];`,
这个流程对应 X, Y 的先后调用关系是不确定的, 执行时可能会向前或向后引用数据, 图的拓扑结构保证了数据引用的唯一性, 但数据有效性无法保证.
因此, 在编译器分析命名重复时, 会向每一处引用的全部上下游可达节点查找名称标记, 验证源的唯一性, 并明确引用关系.

## 5. 控制流语义（详细）

### 5.1 触发器

触发器是执行流的唯一入口。位于 `Component` 内部的触发器会被注册到文件级的图实例上。同一个触发器的多处连接视为同一颗执行树, 可以有变量的互相连接.

### 5.2 顺序链

在同一 `>> {}` 块、`If/Switch` 分支或顶层链中，按 `.Fun()` 或 `>> Fun()` 书写的节点按顺序自动连接。

### 5.3 并行分支 ( `>> {...}` )

* `>> {...}` 块中的所有分支均被视为“并行”执行（尽管在单线程中是顺序的）。
* **执行顺序**：严格按照分支键（Key）的**整数字面量升序**，进行**深度优先**执行。
    * 在 `>> { 1: X(), 0: Y() }` 中，`Y()` (key=0) 所在的链会先于 `X()` (key=1) 所在的链执行。

### 5.4 多入节点语义

* **规则**：当多条控制流边（来自并行分支或 `>> "id"` 跳转）汇入同一个节点时，该节点将被**激活多次**，每条入边到达时触发一次。
* **无自动合并**：节点本身不具备“等待所有输入”的逻辑；它们是即时触发的。

### 5.5 合流语义

* **`>> 0()` (块合流)**：
    * 用于 `>> {}` 或 `If/Switch` 块内部。
    * 语义：执行流跳转到该块*之后*的第一个主干节点。
    * 边界情况：如果块之后没有主干节点（即语句结束），`>> 0()` 是一个有效的“空操作”（等同于 `>> -1()`），但编译器会发出警告。
* **`Branch["id"]` (锚点合流)**：
    * `Branch["id"].FunX()` 或 `.FunY().Branch["id"]` 用于**定义**一个锚点。
    * `.FunZ() >> "id"()` 用于**跳转**到该锚点。
    * **错误**：重复定义 Branch id 或 `>> "id"()` 到一个不存在的 id 都是编译时错误。

设计理念: 块合流与锚点合流在形式上是一致的, 只不过块合流保留了 0 和 -1 两个名称. 这种一致性的行为采用一致的定义的方式在本DSL设计中很常见.

### 5.6 If / Switch 选择语义

* **单一分支**：`If` 和 `Switch` 保证只有一条控制流路径会被执行。
* **分支键**：`Switch` 的键必须是字面量，不能是变量。

### 5.7 链式与延迟执行操作符 (>> vs <<)

* **`>>` (顺序链)**：
    * 语义：`A >> B >> C` 等价于 `A.B.C`。
    * 执行顺序：A 执行完毕 -> B 执行完毕 -> C 执行完毕。
    * 等价展开：`A >> {0: B, 1: 0()}.C`。
* **`<<` (延迟/挂起执行)**：
    * 语义：`A << B >> C...` 表示在 A 执行后，先执行 C 及其后续的所有内容，待 C 的整条链路完全结束后，再回过头来执行 B。
    * 等价展开：`A >> {0: 0(), 1: B}.C...` (注意：此处 B 位于分支 1，而 C 接在分支 0 的合流之后，但根据定义，`<<` 隐含了 B 是在 C *之后* 执行的逆序逻辑，或者更准确地说是“挂起 B，先走主干 C”)。
    * **多重挂起**：当链上有多个 `<<` 时（如 `A << B << C >> D`），执行顺序为：先执行主干 `D`，待 `D` 结束后执行 `C`，待 `C` 结束后执行 `B`。即“后挂起的先执行”（栈式行为）或“从后向前依次执行被挂起的节点”。

## 6. 运算流语义 (详细)

### 6.1 `$(...)` 定义与求值

* `$(...)` 是创建运算流节点的唯一方式。
* **求值时机**：运算节点在它产生的输出被**执行节点引用时**，才会被实时求值。
* **执行链中的位置**：
    * 在严格模式下, 运算节点必须位于被引用位置之前, 仅有当前触发树下的调用链经过的运算节点才能被引用.
    * 在宽松模式下, 运算节点可以位于被引用位置之后, 但必须确保该位置位于引用位置的可到达路径上.

### 6.2 `$(...)` 依赖与捕获

* **捕获列表**：`$( (a,b) => ... )` 中的 `(a,b)` 是**强制性**的依赖捕获列表。
* **规则 1 (详尽列出)**：`$(...)` 内部使用的所有 `function output` 变量，**必须**在捕获列表中声明。
* **规则 2 (例外)**：`Self.*`, `node.*` 变量不需要（也不应该）在捕获列表中声明，它们可被直接访问。
* **规则 3 (可选)**：`_x*` 临时变量可以在捕获列表中声明，这会增强逻辑, 但也会增加阅读时的记忆负担.
* **错误 (阻断)**：
    * `.$((a) => a + b)` —— `b` 未在捕获列表 `(a)` 中，编译时错误。
    * `.$((a, node) => a + node.b)` —— `node` 不应出现在 `(a, node)` 的捕获列表中，编译时错误。
* **规则 3 (默认值)**：
    * 如果一个变量 `x` *已在*捕获列表（如 `.$((x) => ...)`），但 `x` 来源于一个尚未执行的 `If/Switch` 分支，此时引用 `x` **不会报错**。
    * `x` 将返回其类型的默认值（`0`, `false`, `""` 等）。

### 6.3 多次调用语义

* 如果两个*不同*的执行节点（如 `A` 和 `B`）都依赖了同一个运算节点（或 `const` 纯函数），该运算节点将在 `A` 激活时求值一次，并在 `B` 激活时*再次*求值。
* 在*单个*执行节点内，即使多个入参依赖同一个运算节点，该运算节点也只求值一次。

## 7. 变量与生命周期

本 DSL 包含四类严格区分的变量命名空间：

### 7.1 `function outputs` (函数/节点输出)

* **来源**：`[OnTrigger()[a]]`, `.Fun()[b]`, `$(...)[c]`。
* **生命周期**：在“同一触发器执行树”内有效。
* **语义**：**只读**。一旦被创建，其值在当前执行树中不可变。
* **约束**：在同一触发器树下，其（别名）名称必须唯一。

### 7.2 `global (Self)` (全局变量)

* **来源**：`declare global { namespace Self { val: int = 0; }`。
* **生命周期**：**持久化**。跨越所有触发器，与挂载实例绑定。
* **语义**：**可读写**。通过 `.SetVal(Self.val, ...)` 修改。

### 7.3 `node vars (node)` (节点图变量)

* **来源**：`declare namespace node { list: List; }`。
* **生命周期**：**持久化**。作为图的实例存在，每次挂载创建一个新的实例。
* **语义**：**可读写**。通过 `.SetVal(node.list, ...)` 修改。

### 7.4 `temporary (_x)` (临时变量)

* **来源**：`const _x: int = 0`。
* **生命周期**：**单次触发**。在每次触发器被激活时创建（重置为初始值），在执行树结束时销毁。
* **语义**：**可读写**。用于在同一执行树中的不同节点间传递可变状态。通过 `.SetVal(_x, ...)` 修改。

## 8. 复合节点 (Component) 语义

### 8.1 定义与调用

* `function ComponentName(...)` (首字母大写)：定义一个包含控制流的复合节点。
* `const func_name = (...)` (首字母小写, 下划线连接)：定义一个纯运算函数，只能在 `$(...)` 内部或执行节点参数中调用。

### 8.2 内部触发器

Component 内部允许定义触发器（如 `[OnCreate()]`）。这些触发器被视为注册在*文件级*的图上，而非 Component 实例上, 内外共享一个触发器。

### 8.3 作用域隔离

* **`Branch id` 隔离**：Component 内部定义的 `Branch["id"]` 对外部不可见。外部也无法 `>> "id"()` 跳转到 Component 内部。

### 8.4 入口与出口语义

* **`In()` (入口)**：`In()` 标记该 Component 合法的控制流入口位置, 同时也是触发后续执行链的位置。对于多个入口位置, 可以通过 `In("Id")` 区分.
* **`return` (声明)**：`return ExecNode<{out_val: type}>("exit_id_1", "exit_id_2")` 用于*声明*该 Component 的参数输出与合法的控制流出口 ID 列表。ID列表为空代表唯一的默认出口.
* **`Out()` (触发出口)**：在 Component 内部调用 `.Out()` 会触发默认的出口, 通过 `Out("exit_id_2")` 区分出口位置。
* **错误 (阻断)**：调用 `.Out("invalid_id")`，如果 `"invalid_id"` 不在 `return` 声明的列表中，将导致编译时错误。
* **执行时序 (深度优先)**：
    * 当 `.Out()` 被调用时，控制流将**跳转到外部的操作挂起**, 继续执行后续内容, 等待内部操作完成后再触发返回, 执行外部节点。
    * `A().Out().B()...` 的行为等价于 `A() << Out() >> B()...`
    * 一条链上多个分支和 `Out()` 的执行顺序与等价表示的结构的顺序一致.
    * `Out()`操作永远附加在前一个节点上, 始终作为上个节点的最后一个分支执行.


## 9. 跨文件规则与模块化

* **执行流隔离**：控制流不能跨越文件边界。
* **导入模板**：`import { MyComponent }` 导入的是模板定义。
* **本地实例化**：调用导入的 `MyComponent()` 时，它将在*当前*文件的上下文中实例化并执行。其内部定义的 `Branch id` 仍受其自身定义的隔离约束。

## 10. 错误/警告策略 (实现建议)

### 10.1 错误 (阻断)

* **命名冲突**：
    * `function output` 别名在同一触发器树中重名。
    * `Branch id` 在同一作用域中重复定义。
* **依赖/引用失败**：
    * `$(...)` 中引用了未在捕获列表中声明的 `function output`。
    * `>> "id"` 跳转到未定义的 `Branch id`。
    * `Out("id")` 触发了未在 `return` 中声明的出口。
* **结构错误**：
    * 检测到控制流或数据流循环。
    * `Switch` 使用了非字面量作为分支键。
* **非法使用**：
    * 在 `$(...)` 之外调用纯运算函数 (`const funcName`)。
    * 在 `$(...)` 内部调用含控制流的 `Component` (`function ComponentName`)。

### 10.2 警告 (允许，但提示)

* `Switch(val).FunX()`：使用了省略语法的 `Switch`，导致只有 `null` (default) 分支会执行后续主干。
* `>> 0`：在 `>> {}` 或 `If/Switch` 块末尾使用，但其后没有主干流可合并。

---

## 11. 示例与片段

### 11.1 单路径顺序流
(示例代码留空)

### 11.2 多分支并行与合流
(示例代码留空)

### 11.3 Switch/If 示例
(示例代码留空)

### 11.4 component 内含触发器示例
(示例代码留空)

### 11.5 临时变量与 SetVal 示例
(示例代码留空)

### 11.6 $() 多输出示例
(示例代码留空)

---

## 12. 中间表示 (IR) 建议 (紧凑)

* **GraphModule**：文件级容器，包含所有 Triggers, Components, 和 Declarations。
* **TriggerNode**：执行流起点。
* **ExecNode**：执行节点 (e.g., `FunA`)。
* **DataNode/EvalNode**：运算节点 (e.g., `$(...)`)。
* **Edge (Control/Data)**：显式连接的边。
* **BranchAnchor**：`Branch["id"]` 的 IR 表示，作为跳转目标。
* **ComponentTemplate**：`function ComponentName` 的定义。
* **ComponentInstance**：`ComponentName()` 的调用实例。
* **SymbolTable/VariableSymbol**：用于管理四个命名空间，并在解析时检查唯一性和依赖。
* **Merge/Select Nodes**：显式的 IR 节点用于表示 `>> {}`（并行）和 `If/Switch`（选择）的逻辑。

---

## 13. 可视化 & 逆向映射 (留档)

### 13.1 从代码到图

* `.FunA().FunB()` 映射为 `[Node A] -> [Node B]`。
* `.FunA() >> { 0: FunB(), 1: FunC() }` 映射为 `[Node A]` 分叉到 `[Node B]` 和 `[Node C]`。
* `.FunA() >> "id"` 和 `Branch["id"].FunB()` 映射为从 `[Node A]` 到 `[Node B]` 的显式跳转边。
* `$(...)` 节点应可视化为依附于其执行节点的数据源。

### 13.2 从图到代码

* **挑战**：保持 `Branch id` 的稳定性和可读性是“往返 (Round-trip)”的关键。
* **建议**：编辑器在保存为图的二进制格式时，应保留（或自动生成）用于合流的 `Branch id`，以便在逆向转译回 DSL 时能恢复结构。

---

## 14. 附录

### 14.1 关键字汇总
(留空，待填充)

### 14.2 字面量 & 正则约束
(留空，待填充)

### 14.3 错误码/警告码列表（草案）
(留空，待填充)

### 14.4 术语表
(留空，待填充)