<div align="center">

# Legacy Node Graph System Architecture Reference
**Legacy Node Graph System Architecture Reference**

| Document Version | Date | Status | Scope |
| :---: | :---: | :---: | :---: |
| 1.0.0 | 2026-01-02 | Official Release | .gia file parsing / System refactoring / Data migration |

</div>

This document aims to provide tool developers and system architects with a "source of truth" regarding this legacy system. It strips away confusing original naming, uses terms semantically refactored by us, while also preserving explanations of the original data characteristics.

Data file reference: [utils/protobuf/gia.proto](../../utils/protobuf/gia.proto)

## Table of Contents

- [1. Introduction](#1-introduction)
  - [1.1 System Overview](#11-system-overview)
  - [1.2 Core Design Philosophy](#12-core-design-philosophy)
  - [1.3 Key Terminology](#13-key-terminology)
- [2. Resource & Asset System](#2-resource--asset-system)
  - [2.1 AssetBundle Structure](#21-assetbundle-structure)
  - [2.2 Global Identifier System (ResourceLocator)](#22-global-identifier-system-resourcelocator)
- [3. Node Architecture](#3-node-architecture)
  - [3.1 The Shell-Kernel Model](#31-the-shell-kernel-model)
  - [3.2 Composite & Interface Nodes (NodeInterface)](#32-composite--interface-nodes-nodeinterface)
  - [3.3 Client Proxy Mechanism](#33-client-proxy-mechanism)
- [4. Graph Execution Logic](#4-graph-execution-logic)
  - [4.1 The Graph Container](#41-the-graph-container)
  - [4.2 Entry Points & Slots](#42-entry-points--slots)
  - [4.3 Signal & Event System](#43-signal--event-system)
- [5. Type & Value System](#5-type--value-system)
  - [5.1 Dual Type System](#51-dual-type-system)
  - [5.2 Recursive Value Container (TypedValue / VarBase)](#52-recursive-value-container-typedvalue)
  - [5.3 Generic Instantiation Metadata (DynamicTypeMetadata)](#53-generic-instantiation-metadata-dynamictypemetadata)
- [6. Conclusion](#6-conclusion)

## 1. Introduction

### 1.1 System Overview

This system is a visual logic scripting system based on a **Client-Server (C/S) decoupled architecture**. Unlike traditional standalone node graphs, this system, while authored in a unified editor, is strictly divided into two independent execution environments at runtime:

1.  **Backend Logic Environment (Server Runtime)**: Responsible for authoritative game logic, state management, and database read/write operations.
2.  **Frontend Presentation Environment (Client Runtime)**: Responsible for UI rendering, local predictive calculations, and communication with the server via RPC proxies.

The data carrier for this system is the `.gia` (Genshin Impact Assets) file. This is not just a single graph file, but a **self-contained Asset Bundle**, which includes the main logic and all dependency definitions required for its operation (such as dynamically generated signal stubs, struct definitions, etc.).

### 1.2 Core Design Philosophy

Through reverse analysis of exported data, we identified that this system adheres to the following three core design principles:

*   **Shell-Kernel Separation**:
    *   **Shell**: Defines the node's UI appearance (pin layout, name). Located in client resources.
    *   **Kernel**: Defines the node's underlying implementation (C++ function pointer). Located in the dual-end engine.
    *   **Polymorphic Mapping**: A Shell can be mapped to different Kernels through **constraint solving** (e.g., an `Add` node selects `Add_Int` or `Add_Float` based on type).

*   **Strong Contract via Generics**:
    *   The system performs strict serialization based on Protobuf.
    *   To support dynamic logic within a static type system, the system designed a recursive **value system (`TypedValue`)** that supports arbitrary nesting of List, Map, and Struct, and maintains type information through metadata even in a null state.

*   **Interface Proxy**:
    *   For subgraph calls, signal sending, and struct operations, the system does not directly expose internal logic. Instead, it generates a standard node shell through **composite node definition (`NodeInterface`)**. This makes all complex operations appear as ordinary nodes in the editor.

### 1.3 Key Terminology

| Term | Definition |
| --- | --- |
| **AssetBundle** | A single `.gia` file, containing the primary resource and all dependencies. |
| **ResourceLocator** | The core indexing key of the system, uniquely identifying a resource via a three-dimensional coordinate system (Origin/Category/Kind). |
| **Shell** | The UI definition ID of a node. |
| **Kernel** | The execution logic ID of a node. |
| **Stub** | A "fake" node automatically generated by the system, serving as an RPC sender or struct accessor. |
| **Blackboard** | A local variable pool internal to a graph, some variables of which can be exposed externally as parameters. |
| **TypedValue** | A generic value container with type metadata. |

---

## 2. Resource & Asset System

This chapter details the physical storage format of data (`.gia`) and the system-wide common resource addressing mechanism.

### 2.1 AssetBundle Structure

A `.gia` file is essentially a **dependency closure**. It ensures that when a logic graph is loaded, all dynamic definitions it references (which might not exist in static code) can be correctly resolved.

#### 2.1.1 Physical Structure

A standard `AssetBundle` includes the following parts:

1.  **Primary Resource**:
    *   The core content of the file. Typically a `NodeGraph` (e.g., character skill logic) or `StructureDefinition` (struct definition).
    *   When the editor opens the file, this is the object that is loaded and displayed.
2.  **Dependencies**:
    *   **Definition**: A list of `ResourceEntry`.
    *   **Content**: Contains all **non-static resources** referenced by the primary resource.
    *   **Typical Cases**:
        *   When a "send signal `PlayerDead`" node is used in the main graph, a corresponding **RPC Stub** definition is automatically generated by the system and serialized into this dependency pool.
        *   When user-defined structs are used in the main graph, their definitions are also packaged here.
3.  **Metadata**:
    *   Includes redundancy checks.

#### 2.1.2 Legacy Wrappers

In the original data, there are multi-layered nested structures such as `NodeGraphWrapper`.

*   **Purpose**: This was to achieve type erasure under Protobuf's `oneof` feature and to provide a buffer layer for future additions of generic header information (e.g., encryption bits).
*   **New System Handling**: At the logical level, we will directly access `ResourceEntry.payload`, ignoring the intermediate Wrapper layers.

### 2.2 Global Identifier System (ResourceLocator)

This is the nerve center of the entire system. All resources (whether graphs, node definitions, or specific entities) are located using a **three-dimensional coordinate system**.

#### 2.2.1 Three-Dimensional Addressing Coordinates

A valid resource ID is determined by the combination of the following three enumerations:

1.  **Origin**: Defines the **ownership** of the resource.
    *   `USER_DEFINED (10000)`: Dynamic assets created by designers/developers (exist in database/files).
    *   `SYSTEM_DEFINED (10001)`: Static assets hardcoded by the program (exist in code/read-only data segment).
2.  **Category**: Defines the **engine subsystem** responsible for handling the resource.
    *   This acts as a dispatcher during loading. For example:
        *   `SERVER_BASIC (20000)`: Sent to the backend logic engine.
        *   `CLIENT_SKILL (20002)`: Sent to the frontend skill system.
        *   `CLIENT_FILTER (20001)`: Sent to the frontend judgment system.
3.  **AssetKind**: Defines the **physical storage structure** of the data.
    *   It tells the deserializer which `message` structure should be used to parse the `payload`.
        *   `CUSTOM_GRAPH (21001)`: Parsed as `NodeGraph`.
        *   `SYS_CALL_STUB (22000)`: Parsed as `NodeInterface` (RPC stub).

#### 2.2.2 Dual ID Semantics: GUID vs ID

Within `ResourceLocator`, there are two ID fields with entirely different meanings:

| Field Name (Refined) | Original Field | Semantic | Applicable Object | Example |
| --- | --- | --- | --- | --- |
| **Asset GUID** | `asset_guid` (4) | **Asset Library GUID** | **Resource Management Layer / File System** points to a specific, serializable user asset file. | AssetBundle dependency list, Entity/Prefab references, system built-in nodes (SYSTEM_DEFINED) usually do not have this field. |
| **Runtime GUID** | `runtime_id` (5) | **Runtime ID** | **Logic Execution Layer / Memory** points to a logical definition, OpCode, or in-memory object handle. | Node graph ID, struct definition ID, signal ID. |

---

## 3. Node Architecture

A node in this system is not a singular entity, but a **runtime composite**. The key to understanding this architecture is distinguishing between "what the user sees (Shell)" and "what the system executes (Kernel)".

### 3.1 The Shell-Kernel Model

To support polymorphism and cross-platform logic, the system splits node definitions into two independent identifiers.

#### 3.1.1 Dual Identifier Mechanism

Each node instance (`NodeInstance`) contains two key references:

1.  **Shell Ref**:
    *   **Definition**: The UI descriptor of the node.
    *   **Function**: Determines the node's name, number of pins, pin names, and arrangement order.
    *   **Location**: Typically points to a definition in the client resource package.
    *   **Immutability**: Regardless of whether the node processes `Int` or `Float`, its `Shell Ref` usually remains unchanged (e.g., both are called "Add").
2.  **Kernel Ref**:
    *   **Definition**: The handle to the node's underlying implementation.
    *   **Function**: Points to the actual C++ function or system instruction executed in the engine.
    *   **Location**: Points to the function registration table of the dual-end engine or a specific RPC stub.
    *   **Variability**: This is key to achieving polymorphism.

#### 3.1.2 Node Lifecycle States

Based on the `Kernel Ref` state, nodes are divided into two modes:
*   **Unresolved / Dirty State**:
    *   **Characteristic**: `kernel_ref` is empty (`null`).
    *   **Scenario**: The user has just dragged a generic node (e.g., `Math.Add`) from the menu but has not yet selected a specific type from the dropdown.
    *   **Behavior**: At this point, the node is logically invalid. The editor will report an error before running checks and will prevent connections (connections automatically assign values) until the user specifies a type.

*   **Resolved / Ready State**:
    *   **Characteristic**: `kernel_ref` has a valid ID.
    *   **Mechanism**: After the user selects a type (e.g., `Int`), the editor queries the **constraint solver** to find the implementation corresponding to `Shell(Add) + Type(Int)` (`Kernel(Add_Int32)`) and writes it into the data.

### 3.2 Composite & Interface Nodes (`NodeInterface`)

In the system, any node that cannot be directly mapped to a single C++ function is described by **`NodeInterface` (formerly CompositeDef)**. This is used not only for user-defined subgraphs but also for system-automatically generated struct operations and signal stubs.

#### 3.2.1 Interface Contract

`NodeInterface` acts as the "function signature" for the node. It defines:

*   **External Pins**: i.e., lists like `inflows`, `inputs`.
*   **Persistent Anchors**: Each pin contains a `persistent_pin_uid`. Even if the internal logic changes (e.g., some nodes are deleted within the subgraph), as long as the UID of the external interface remains unchanged, the connections in the external graph will not break.

#### 3.2.2 The Template Matrix

The system determines the true behavior pattern behind a node by combining `template_root` (formerly `which`) and `template_sub` (formerly `subWhich`).

| Node Type | Template Root | Template Sub | Behavior Description |
| --- | --- | --- | --- |
| **User Subgraph** | `USER_COMPOSITE (6)` | `NONE` | **Reference Mode**. Node logic points to another `NodeGraph` resource. This subgraph will be expanded at runtime. |
| **Send Signal** | `SUB_TEMPLATE (1)` | `SIGNAL_SUB (8)` | **RPC Mode**. The node is an automatically generated sender based on a signal definition. |
| **Listen Signal** | `LISTEN_SIGNAL (2)` | `SIGNAL_SUB (8)` | **Event Mode**. The node is the reception entry point for a signal. |
| **Deconstruct Struct** | `STRUCT (5)` | `STRUCT_SUB (4)` | **Access Mode**. The node automatically generates output pins for corresponding fields based on the struct definition. |
| **Modify Struct** | `SUB_TEMPLATE (1)` | `MODIFY_STRUCT (3)` | **Access Mode**. The node generates input pins for corresponding fields, used to modify struct values. |

### 3.3 Client Proxy Mechanism

In the frontend presentation environment (Client Runtime), a large number of nodes (especially skill logic `CLIENT_SKILL`) are not executed locally but need to drive server logic. To avoid writing corresponding client C++ code for every server instruction, the system designed a generic **RPC proxy mechanism**.

#### 3.3.1 Kernel 2000: Generic Gateway

Most client execution nodes have their `kernel_ref` pointing to ID **2000** (or its variants).
This is a **Generic RPC Gateway**. Its logic is very simple:

1.  Read metadata pins (OpCode).
2.  Serialize and package all input data pin values.
3.  Send to the server over the network.

#### 3.3.2 Type 5 Pin: Metadata Channel

To let the generic Kernel 2000 know "which function to call," the system introduced a special pin type: **PinSignature.Kind = META_RPC_OPCODE (5)**.

*   **OpCode Carrier**:
    *   Each proxy node has a hidden Type 5 pin (usually Index 0).
    *   The `binding_meta` or `source_ref` field of this pin stores the **Shell ID of the target server logic node**.
    *   **Example**: A client's "Deal Damage" node has Kernel 2000, but its Pin 0 is bound to the server-side "ApplyDamage" ID.

*   **Dynamic Routing**:
    *   For `SendSignal` nodes, in addition to OpCode, there is a second Type 5 pin (`META_TOPIC_NAME`).
    *   It carries the signal name (e.g., "PlayerDead") or its Hash.
    *   The gateway will place this as a **Routing Key** in the packet header, and the server will dispatch events accordingly.

This is Chapter 4 of the "Legacy Node Graph System Architecture Reference". This chapter expands the scope from individual nodes to the entire **graph**'s operational mechanism, focusing on explaining the "penetration" mapping logic of composite nodes, the variable scope within the graph, and the context injection mechanism of the event-driven system.

---

## 4. Graph Execution Logic

A `NodeGraph` is not only a container for nodes, but it also defines the **Boundary**, **Scope** of data, and **Interface** of the logic.

### 4.1 The Graph Container

A complete node graph at runtime consists of the following three core layers:

#### 4.1.1 Execution Layer

*   **Main Body**: The `nodes` list (`NodeInstance`).
*   **Mechanism**: This is the actual logic body of the graph. The engine traverses this list, executing nodes sequentially based on the connection relationships of Control Flow pins.
*   **Index**: Each node has a unique `index` (int32), which is the sole handle for internal addressing within the graph. Connection data directly references this handle via `target_node_index`.

#### 4.1.2 Interface Layer

When a graph is nested within another graph as a "Composite Node", it must communicate with the outside world via **InterfaceMapping**.

*   **Penetration Mapping**:
`InterfaceMapping` defines how external pins "penetrate" to connect to internal nodes.
    *   **Input Mapping**: Input pins of an external `Composite` node map to input pins of an internal node.
    *   **Output Mapping**: Output pins of an internal node map to output pins of an external `Composite` node.

*   **Flattening Optimization**: Although the data structure is layered, it is presumed that the server performs **Graph Flattening** during the loading phase, directly redirecting external connections to the memory addresses of internal nodes, thereby eliminating runtime recursive call overhead.

#### 4.1.3 Data Layer (The Blackboard)

The graph has an independent local variable pool, called the **Blackboard (`Blackboard` / `GraphVariable`)**.

*   **Scope**: By default, variables are only visible within the current graph (Private).
*   **Exposure Mechanism (`is_public`)**:
    *   If a variable is marked as `is_public = true`, it will become a **configuration parameter** for that graph.
    *   In the editor, when the graph resource is selected, the properties panel will display these variables, allowing designers to adjust values (e.g., "skill cooldown," "damage multiplier") without opening the graph.
*   **Type System**: Variables use `ServerTypeId` to define their type and `TypedValue` to store their value. This is central to internal data persistence and state sharing within the graph.

### 4.2 Entry Points & Slots

Not all graphs start from a single "Start" node. The activation method of graphs varies depending on the subsystem.

#### 4.2.1 Trigger Slot (`entry_slot_index`)

*   **Definition**: In the skill (`SKILL`) or filter (`FILTER`) systems, external systems may call graphs through specific "slots".
*   **Mechanism**: `entry_slot_index` tells the engine which part of the internal logic should be activated when an external signal triggers this slot (typically corresponding to a `NodeGraphStarts` node, whose Index aligns with this field).
*   **Default Value**: Usually 1, corresponding to the default first node `NodeGraphStarts`.

#### 4.2.2 Polling Interval (`evaluation_interval`)

*   **Applicable Objects**: Only for filter graphs (`FILTER_NODE_GRAPH`).
*   **Mechanism**: Defines the frequency at which this logic graph is re-evaluated. For example, `0.3` means the judgment logic is executed every 0.3 seconds. This is a **heartbeat mechanism** automatically scheduled by the system.
*   **Issue**: The polling cycle is determined by the external calling component; the node graph's own value is invalid.

### 4.3 Signal & Event System

This system uses a **Publish/Subscribe (Pub/Sub)** pattern to handle asynchronous logic.

#### 4.3.1 Signal Publishing (Send Signal)

*   **Client**: Sent via a proxy node (Kernel 2000). Contains `OpCode` (RPC header) and `Topic` (signal name).
*   **Server**: Sent via a `SendSignal` node (generates stub).
*   **Routing**: Signals do not directly point to a specific graph but are broadcast to the **Entity**'s message bus.

#### 4.3.2 Signal Subscription (Listen Signal) (Kernel 2001)

*   **Node**: `ListenSignal` (generates stub).
*   **Mechanism**: When the server loads a graph, it registers a listener. When a matching signal (consistent Topic) arrives at the entity, this node is activated.

#### 4.3.3 Context Injection

When a graph is triggered by a signal, it needs to know the data (Payload) carried by the signal.

*   **Context Declaration (`context_declaration`)**:
*   Located on the entry node (usually Kernel Ref 2001).
*   It declares: "This graph is triggered by `Signal_X`."

*   **Data Retrieval**:
*   Special "Get Signal Data" nodes will be generated inside the graph (or additional output pins on the entry node).
*   The data source for these pins is not from connections, but from the **Execution Context**. Before executing the graph, the engine injects the signal's Payload into these context slots.

---

## 5. Type & Value System

The type layer of this system is very complex because it must simulate the flexibility of dynamic languages within static Protobuf structures, while also bridging the heterogeneous environments of C++ servers and C# clients.

### 5.1 Dual Type System

Due to historical iteration and architectural isolation, the system has two incompatible sets of type ID numbers. Understanding this mapping is a prerequisite for correctly parsing data.

#### 5.1.1 Mapping Table

| Type | Server ID (Backend) | Client ID (Frontend) | Notes |
| --- | --- | --- | --- |
| **Unknown** | `0` | `0` | |
| **Entity** | `1` | `1` | Runtime object reference |
| **Int32** | `3` | `3` | |
| **Boolean** | `4` | `5` | **Note ID misalignment** |
| **Float** | `5` | `7` | **Note ID misalignment** |
| **String** | `6` | `9` | |
| **Vector3** | `12` | `11` | |
| **List<Int>** | `8` | `4` | Server IDs are scattered, Client IDs are sequential |
| **List<Entity>** | `13` | `2` | |
| **Struct** | `25` | N/A | Client generally cannot directly manipulate generic structs |
| **Map (Dict)** | `27` | N/A | Client simulates via List<Pair> |

#### 5.1.2 Heterogeneous Processing Strategy

*   **Data files as dictionaries**: `.gia` files, when storing node definitions, often include both `var_type_shell` (Client ID) and `var_type_kernel` (Server ID). The parser should choose to read the appropriate field based on the current runtime environment.
*   **Client Limitations**: The client environment does not support deep operations on `Map` and `Struct`. If data with Server ID 25 or 27 is encountered, the client usually treats it as a "black box handle" or read-only data.

### 5.2 Recursive Value Container (`TypedValue`)

`TypedValue` (formerly `VarBase`) is the system-wide generic data carrier. It uses a **Recursive Composition** pattern to build complex data structures.

#### 5.2.1 Storage Structure (Polymorphic Storage)

Utilizing Protobuf's `oneof` feature, `TypedValue` can store any basic or composite type.

*   **Atomic Types**: Directly stored in fields like `val_int`, `val_float`.
*   **Container Types**:
    *   `val_list`: Contains a `ListStorage`, with `repeated TypedValue` internally.
    *   `val_struct`: Contains a `StructStorage`, with `repeated TypedValue` internally (corresponding to the struct field order).
*   **Recursion**: Because elements within `ListStorage` are also `TypedValue`, the system naturally supports infinitely nested structures like `List<List<Int>>` or `List<Struct>`.

#### 5.2.2 UI Rendering Hints (Widget Hints)

To address the issue of "same data type but different usage" (e.g., `Int` can be a quantity or an enum ID), `TypedValue` includes a `widget` field:

*   `W_ENUM_PICKER (6)`: Hints the editor to render as a dropdown enum, rather than a numeric input box.
*   `W_ID_INPUT (1)`: Hints the editor to render as a resource selector (e.g., selecting a Prefab), rather than inputting a 64-bit integer.

#### 5.2.3 Change Tracking (`is_explicitly_set`)

This field is a bitmask (or boolean flag).

*   **Background**: Protobuf's default value mechanism cannot distinguish between "user entered 0" and "user did not enter (default 0)".
*   **Logic**: If `is_explicitly_set == 0`, the runtime should ignore the value in `storage` and instead use the **default value** defined by the node or **connection input**.

### 5.3 Generic Instantiation Metadata (`DynamicTypeMetadata`)

This is the most obscure yet crucial design in the system, used to resolve **generic container null value ambiguity**.

*   **Problem**: When a `List<StructA>` is empty, its `val_list` field contains no elements. At this point, the editor cannot determine what the "generic parameter T" of this list is.
*   **Mechanism**: `extra_meta` (formerly `ComplexValueStruct`) provides a **static type template**.
*   It directly informs the system via flattened fields (such as `target_struct_id` or `map_config`): "Although this container is currently empty, it will eventually contain `StructA`."

*   **Purpose**: This is primarily used for editor-side instantiation of new elements (Factory Pattern) and UI layout initialization.

---

## 6. Conclusion

This document provides a complete deconstruction of the internal mechanisms of the legacy node graph system. Despite its significant historical baggage (such as dual type IDs, hardcoded magic numbers), its core architecture—**Shell/Kernel separation**, **AssetBundle dependency management**, and the **recursive value system**—demonstrates a high degree of flexibility and foresight.

The design of the new system should inherit these core ideas, while simultaneously using more semantic interfaces (such as our refactored Protobuf definitions) to mask underlying complexity, thereby building a modern logic engine that is both compatible with historical data and easy to maintain.