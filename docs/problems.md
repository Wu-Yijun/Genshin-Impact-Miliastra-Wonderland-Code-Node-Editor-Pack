1.2.3 合流（Merge）与跳转（Goto）
1.3.1 捕获列表（Capture List）
捕获变量允许来自：
1.4 Component（组件）模型
1.4.1 组件结构
显式可视化端口声明 return ExecFunc({ ...outputs })

2.2 大改
2.3 扩充

你的语法概要中遗漏/误解了一些较为重要的内容, 请结合我的描述重新理解, 并给出更严谨且正确的 EBNF .
1. Component定义中, 返回值是 `return ExecFunc<{ arg1:type1, arg2:type2,... }>("Out_id_1", "Out_id_2");` 其中, 通过泛类指定输出参数类型, 通过函数参数指定输出引脚标签. 最小结构是 `return ExecFunc<{}>()` 无输出参数, 用默认引脚.
2. Component定义中, 执行链必须以 In() 或 In("id") 开头, 但 Id() 也可以放在执行链中. Out() 同样不需要在表达式的尾部, 也可以放在任意位置.
3. 系统定义的执行函数都是单入单出的(仅除了If/Switch/Loop/ForEach有多个出口). 用户定义的Component如果有多个入口, 直接调用是默认走第一个入口进入, 如果需要指定入口不是以Tag的形式, 而是使用函数`Selector(MyComponent, "PortId", ...args)` 进行调用; 对于多个执行链连接同一个用户定义组件的情况, 通过在文件顶层使用 `const CompInstance = Shared(MyComponent)` 的方式创建组件实例, 然后通过 `CompInstance("PortId", ...args)` 的方式调用; 或通过创建 `const CompPortInstance = Shared(MyComponent, "PortId")` 的方式创建组件端口实例, 然后通过 `CompPortInstance(...args)` 的方式调用, 这样明确声明了所有调用者调用的同一个节点, 而不是组件的展开. 
4. 此外, 所有函数的调用结构都是 `<NodeName>( arguments? )[ capture? ]( cases? )` 的模式, 只是大多数函数没有 cases , 也就省略了, 对于四个多出的系统函数, 与用户定义的多出的函数, 选择分支行为都是一致的, 为 `If(pred)( true = FunA().FunB(), false = FunC().FunD() )`. 并**没有额外的特殊结构`If(){}`之类的形式**  
5. 函数调用不要再前面加 `.` , `.` 的含义是连接成同一条链. 因此 `A() >> B()` 或 `A() . B()` 是合法的, 任何两个元素中间有且仅有一个间隔, 仅为`.`,`<<`,`>>`,`:`,`=` 中一个, 分支/选择的`:`与`=`后的函数也不加 `.`.
6. 所谓的转跳/合流, 都是一种东西, 之所以 `>> 0()` 可以看作是转跳, 是因为它后面没东西了, 所以跳出去的链条执行完, 回来向后执行, 发现后续为空, 于是就结束了. 如果 有 `>> 0().A() >> 0().B()` , 会在执行完外部的节点后, 回来执行 A() 函数, 然后又跳出去执行外面的节点, 完毕后再回来执行 B().

操作符优先级是 `<<` `>>` 大于 `.` , 因此如果 `A << B >> C` 的BC间忘记形成对称结构而直接用 `.` 连接会导致 B.C.... 全部被挂起直到遇到第一个 >>或 <<. 